var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#SymbolicIntegration.integrate","page":"API Reference","title":"SymbolicIntegration.integrate","text":"integrate(f, x)\n\nCompute the symbolic integral of expression f with respect to variable x using all available methods.\n\nArguments\n\nf: Symbolic expression to integrate (Symbolics.Num)\nx: Integration variable (Symbolics.Num)  \n\nExamples\n\njulia> using SymbolicIntegration, Symbolics\njulia> @variables x\njulia> integrate(2x)\nx^2\n\njulia> integrate(sqrt(x))\n┌ Warning: NotImplementedError: integrand contains unsupported expression sqrt(x)\n└ @ SymbolicIntegration ~/.julia/dev/SymbolicIntegration.jl_official/src/methods/risch/frontend.jl:826\n\n > RischMethod failed returning ∫(sqrt(x), x) \n > Trying with RuleBasedMethod...\n\n┌-------Applied rule 1_1_1_1_2 on ∫(sqrt(x), x)\n| ∫(x ^ m, x) => if \n|       !(contains_var(m, x)) &&\n|       !(eq(m, -1))\n| x ^ (m + 1) / (m + 1)\n└-------with result: (2//3)*(x^(3//2))\n(2//3)*(x^(3//2))\n\njulia> integrate(abs(x))\n┌ Warning: NotImplementedError: integrand contains unsupported expression abs(x)\n└ @ SymbolicIntegration ~/.julia/dev/SymbolicIntegration.jl_official/src/methods/risch/frontend.jl:826\n\n > RischMethod failed returning ∫(abs(x), x) \n > Trying with RuleBasedMethod...\n\nNo rule found for ∫(abs(x), x)\n\n > RuleBasedMethod failed returning ∫(abs(x), x) \n > Sorry we cannot integrate this expression :(\n\n\n\n\n\n\nintegrate(f, method)\n\nIf f contains only one symbolic variable, computes the integral of f with respect to that variable, with the specified method, or tries all available methods if not specified.\n\n\n\n\n\nintegrate(f, x, method::AbstractIntegrationMethod=RischMethod(); kwargs...)\n\nCompute the symbolic integral of expression f with respect to variable x  using Risch integration method.\n\nArguments\n\nf: Symbolic expression to integrate (Symbolics.Num)\nx: Integration variable (Symbolics.Num)  \nmethod: Integration method to use (AbstractIntegrationMethod, default: RischMethod())\n\nKeyword Arguments\n\nMethod-specific keyword arguments are passed to the method implementation\n\nReturns\n\nSymbolic expression representing the antiderivative (Symbolics.Num)\n\nExamples\n\n# Explicit method with options\nintegrate(1/(x^2 + 1), x, RischMethod(use_algebraic_closure=true))  # atan(x)\n\n# Method configuration\nrisch = RischMethod(use_algebraic_closure=false, catch_errors=true)\nintegrate(exp(x), x, risch)  # exp(x)\n\n\n\n\n\nintegrate(f, x, method::AbstractIntegrationMethod=RuleBasedMethod(); kwargs...)\n\nCompute the symbolic integral of expression f with respect to variable x using rule based method.\n\nArguments\n\nf: Symbolic expression to integrate (Symbolics.Num)\nx: Integration variable (Symbolics.Num)  \nmethod: Integration method to use\n\nReturns\n\nSymbolic expression representing the antiderivative (Symbolics.Num) (the +c is omitted)\n\nExamples\n\njulia> integrate(1/sqrt(1 + x), x, RuleBasedMethod())\n┌-------Applied rule 1_1_2_1_33 (change of variables):\n| ∫((a + b * v ^ n) ^ p, x) => if \n|       !(contains_var(a, b, n, p, x)) &&\n|       (\n|             linear(v, x) &&\n|             v !== x\n|       )\n| (1 / ext_coeff(v, x, 1)) * substitute(∫{(a + b * x ^ n) ^ p}dx, x => v)\n└-------with result: ∫1 / (u^(1//2)) du where u = 1 + x\n┌-------Applied rule 1_1_1_1_2 on ∫(1 / (x^(1//2)), x)\n| ∫(x ^ m, x) => if \n|       !(contains_var(m, x)) &&\n|       m !== -1\n| x ^ (m + 1) / (m + 1)\n└-------with result: (2//1)*(x^(1//2))\n(2//1)*sqrt(1 + x)\n\njulia> rbm = RuleBasedMethod(verbose=false)\njulia> integrate(1/sqrt(1 + x), x, rbm)\n\n(2//1)*sqrt(1 + x)\n\n\n\n\n\n","category":"function"},{"location":"api/#Integration-Methods","page":"API Reference","title":"Integration Methods","text":"","category":"section"},{"location":"api/#Available-Methods","page":"API Reference","title":"Available Methods","text":"","category":"section"},{"location":"api/#SymbolicIntegration.RischMethod","page":"API Reference","title":"SymbolicIntegration.RischMethod","text":"RischMethod <: AbstractIntegrationMethod\n\nRisch algorithm for symbolic integration of elementary functions.\n\nFields\n\nuse_algebraic_closure::Bool: Whether to use algebraic closure for complex roots (default: true)\ncatch_errors::Bool: Whether to catch and handle algorithm errors gracefully (default: true)\n\n\n\n\n\n","category":"type"},{"location":"api/#Method-Traits","page":"API Reference","title":"Method Traits","text":"","category":"section"},{"location":"api/#SymbolicIntegration.method_supports_rational","page":"API Reference","title":"SymbolicIntegration.method_supports_rational","text":"method_supports_rational(method::RischMethod)\n\nCheck if the integration method supports rational function integration. Returns true for RischMethod and RuleBasedMethod.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIntegration.method_supports_transcendental","page":"API Reference","title":"SymbolicIntegration.method_supports_transcendental","text":"method_supports_transcendental(method::RischMethod)\n\nCheck if the integration method supports transcendental function integration. Returns true for RischMethod and RuleBasedMethod.\n\n\n\n\n\n","category":"function"},{"location":"api/#Algorithm-Overview","page":"API Reference","title":"Algorithm Overview","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SymbolicIntegration.jl implements the complete symbolic integration algorithms from Manuel Bronstein's book \"Symbolic Integration I: Transcendental Functions\".","category":"page"},{"location":"api/#Supported-Function-Classes","page":"API Reference","title":"Supported Function Classes","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Polynomial functions: ∫xⁿ dx\nRational functions: ∫P(x)/Q(x) dx using Rothstein-Trager method\nExponential functions: ∫exp(f(x)) dx using Risch algorithm\nLogarithmic functions: ∫log(f(x)) dx using integration by parts\nTrigonometric functions: Transformed to exponential form","category":"page"},{"location":"api/#Algorithm-Components","page":"API Reference","title":"Algorithm Components","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The package includes implementations of:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Hermite reduction for rational functions\nRothstein-Trager method for logarithmic parts\nRisch algorithm for transcendental functions\nDifferential field tower construction\nComplex root finding for arctangent terms","category":"page"},{"location":"api/#Internal-Structure","page":"API Reference","title":"Internal Structure","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The package is organized into several algorithm modules:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"rational_functions.jl: Rational function integration algorithms\ntranscendental_functions.jl: Risch algorithm implementation  \ndifferential_fields.jl: Differential field operations\ncomplex_fields.jl: Complex number field handling\nfrontend.jl: User interface and expression conversion","category":"page"},{"location":"api/#Error-Handling","page":"API Reference","title":"Error Handling","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The package defines custom exception types:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"NotImplementedError: For unsupported function types\nAlgorithmFailedError: When no elementary antiderivative exists\nAlgebraicNumbersInvolved: When algebraic numbers complicate the result","category":"page"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"methods/overview/#Integration-Methods-Overview","page":"Integration Methods Overview","title":"Integration Methods Overview","text":"","category":"section"},{"location":"methods/overview/","page":"Integration Methods Overview","title":"Integration Methods Overview","text":"SymbolicIntegration.jl uses a flexible method dispatch system that allows you to choose different integration algorithms. Two methods are implemented, Rule based method and Risch method.","category":"page"},{"location":"methods/overview/#RischMethod","page":"Integration Methods Overview","title":"RischMethod","text":"","category":"section"},{"location":"methods/overview/","page":"Integration Methods Overview","title":"Integration Methods Overview","text":"The Risch method is the complete algorithm for symbolic integration of elementary functions, based on Manuel Bronstein's algorithms.","category":"page"},{"location":"methods/overview/","page":"Integration Methods Overview","title":"Integration Methods Overview","text":"→ See detailed Risch documentation","category":"page"},{"location":"methods/overview/#Rule-based-method","page":"Integration Methods Overview","title":"Rule based method","text":"","category":"section"},{"location":"methods/overview/","page":"Integration Methods Overview","title":"Integration Methods Overview","text":"This method uses a large number of integration rules that specify how to integrate a vast class of mathematical expressions.","category":"page"},{"location":"methods/overview/","page":"Integration Methods Overview","title":"Integration Methods Overview","text":"→ See detailed Rule based documentation","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Risch Method\nOverview\nUsage\nConfiguration Options\nConstructor\nOptions\nuse_algebraic_closure::Bool (default: true)\ncatch_errors::Bool (default: true)\nAlgorithm Components\nRational Function Integration (Chapter 2)\nTranscendental Function Integration (Chapters 5-6)\nSupporting Algorithms\nFunction Classes Supported\nPolynomial Functions\nRational Functions\nExponential Functions\nLogarithmic Functions\nTrigonometric Functions\nLimitations\nPerformance Considerations\nWhen to Use Different Options\nComplexity\nExamples\nBasic Usage\nAdvanced Cases\nMethod Configuration\nAlgorithm References","category":"page"},{"location":"methods/risch/#Risch-Method","page":"Risch Method","title":"Risch Method","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"The Risch method is a complete algorithm for symbolic integration of elementary functions. It implements the algorithms from Manuel Bronstein's \"Symbolic Integration I: Transcendental Functions\". Is implemented using AbstractAlgebra.jl and Nemo.jl.","category":"page"},{"location":"methods/risch/#Overview","page":"Risch Method","title":"Overview","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"The Risch method is currently the primary integration method in SymbolicIntegration.jl. It provides exact symbolic integration for:","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Rational functions: Using the Rothstein-Trager method\nExponential functions: Using differential field towers\nLogarithmic functions: Integration by parts and substitution\nTrigonometric functions: Transformation to exponential form\nComplex root handling: Exact arctangent terms","category":"page"},{"location":"methods/risch/#Usage","page":"Risch Method","title":"Usage","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"using SymbolicIntegration, Symbolics\n@variables x\n\n# Explicit Risch method\nintegrate(1/(x^2 + 1), x, RischMethod())  # atan(x)\n\n# Risch method with options\nrisch = RischMethod(use_algebraic_closure=true, catch_errors=false)\nintegrate(f, x, risch)","category":"page"},{"location":"methods/risch/#Configuration-Options","page":"Risch Method","title":"Configuration Options","text":"","category":"section"},{"location":"methods/risch/#Constructor","page":"Risch Method","title":"Constructor","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"RischMethod(; use_algebraic_closure=true, catch_errors=true)","category":"page"},{"location":"methods/risch/#Options","page":"Risch Method","title":"Options","text":"","category":"section"},{"location":"methods/risch/#use_algebraic_closure::Bool-(default:-true)","page":"Risch Method","title":"use_algebraic_closure::Bool (default: true)","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Controls whether the algorithm uses algebraic closure for finding complex roots.","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"true: Finds complex roots, produces exact arctangent terms\nfalse: Only rational roots, faster for simple cases","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"# With complex roots (produces atan terms)\nintegrate(1/(x^2 + 1), x, RischMethod(use_algebraic_closure=true))  # atan(x)\n\n# Without complex roots (may miss arctangent terms)  \nintegrate(1/(x^2 + 1), x, RischMethod(use_algebraic_closure=false))  # May return 0","category":"page"},{"location":"methods/risch/#catch_errors::Bool-(default:-true)","page":"Risch Method","title":"catch_errors::Bool (default: true)","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Controls error handling behavior.","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"true: Returns unevaluated integrals for unsupported cases\nfalse: Throws exceptions for algorithmic failures","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"# Graceful error handling\nintegrate(unsupported_function, x, RischMethod(catch_errors=true))  # Returns ∫(f, x)\n\n# Strict error handling  \nintegrate(unsupported_function, x, RischMethod(catch_errors=false))  # Throws exception","category":"page"},{"location":"methods/risch/#Algorithm-Components","page":"Risch Method","title":"Algorithm Components","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"The Risch method implementation includes:","category":"page"},{"location":"methods/risch/#Rational-Function-Integration-(Chapter-2)","page":"Risch Method","title":"Rational Function Integration (Chapter 2)","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Hermite reduction: Simplifies rational functions\nRothstein-Trager method: Finds logarithmic parts\nPartial fraction decomposition: Handles complex denominators\nComplex root finding: Produces arctangent terms","category":"page"},{"location":"methods/risch/#Transcendental-Function-Integration-(Chapters-5-6)","page":"Risch Method","title":"Transcendental Function Integration (Chapters 5-6)","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Differential field towers: Handles nested transcendental functions\nRisch algorithm: Complete method for elementary functions\nPrimitive cases: Direct integration\nHyperexponential cases: Exponential function handling","category":"page"},{"location":"methods/risch/#Supporting-Algorithms","page":"Risch Method","title":"Supporting Algorithms","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Expression analysis: Converts symbolic expressions to algebraic form\nField extensions: Builds differential field towers\nRoot finding: Complex and rational root computation\nResult conversion: Transforms back to symbolic form","category":"page"},{"location":"methods/risch/#Function-Classes-Supported","page":"Risch Method","title":"Function Classes Supported","text":"","category":"section"},{"location":"methods/risch/#Polynomial-Functions","page":"Risch Method","title":"Polynomial Functions","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"integrate(x^n, x)           # x^(n+1)/(n+1)\nintegrate(3*x^2 + 2*x + 1, x)  # x^3 + x^2 + x","category":"page"},{"location":"methods/risch/#Rational-Functions","page":"Risch Method","title":"Rational Functions","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"integrate(1/x, x)               # log(x)\nintegrate(1/(x^2 + 1), x)       # atan(x)\nintegrate((x+1)/(x+2), x)       # x - log(2 + x)","category":"page"},{"location":"methods/risch/#Exponential-Functions","page":"Risch Method","title":"Exponential Functions","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"integrate(exp(x), x)            # exp(x)\nintegrate(x*exp(x), x)          # -exp(x) + x*exp(x)\nintegrate(exp(x^2)*x, x)        # (1/2)*exp(x^2)","category":"page"},{"location":"methods/risch/#Logarithmic-Functions","page":"Risch Method","title":"Logarithmic Functions","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"integrate(log(x), x)            # -x + x*log(x)\nintegrate(1/(x*log(x)), x)      # log(log(x))\nintegrate(log(x)^2, x)          # x*log(x)^2 - 2*x*log(x) + 2*x","category":"page"},{"location":"methods/risch/#Trigonometric-Functions","page":"Risch Method","title":"Trigonometric Functions","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"integrate(sin(x), x)            # Transformed to exponential form\nintegrate(cos(x), x)            # Transformed to exponential form  \nintegrate(tan(x), x)            # Uses differential field extension","category":"page"},{"location":"methods/risch/#Limitations","page":"Risch Method","title":"Limitations","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"The Risch method, following Bronstein's book, does not handle:","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Algebraic functions: √x, x^(1/3), etc.\nNon-elementary functions: Functions without elementary antiderivatives\nSpecial functions: Bessel functions, hypergeometric functions, etc.","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"For these cases, the algorithm will:","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Return unevaluated integrals if catch_errors=true\nThrow appropriate exceptions if catch_errors=false","category":"page"},{"location":"methods/risch/#Performance-Considerations","page":"Risch Method","title":"Performance Considerations","text":"","category":"section"},{"location":"methods/risch/#When-to-Use-Different-Options","page":"Risch Method","title":"When to Use Different Options","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Research/verification: catch_errors=false for strict algorithmic behavior\nProduction applications: catch_errors=true for robust operation\nComplex analysis: use_algebraic_closure=true for complete results\nSimple computations: use_algebraic_closure=false for faster execution","category":"page"},{"location":"methods/risch/#Complexity","page":"Risch Method","title":"Complexity","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Polynomial functions: O(n) where n is degree\nRational functions: Depends on degree and factorization complexity\nTranscendental functions: Exponential in tower height","category":"page"},{"location":"methods/risch/#Examples","page":"Risch Method","title":"Examples","text":"","category":"section"},{"location":"methods/risch/#Basic-Usage","page":"Risch Method","title":"Basic Usage","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"@variables x\n\n# Simple cases\nintegrate(x^3, x, RischMethod())                    # (1//4)*(x^4)\nintegrate(1/x, x, RischMethod())                    # log(x)\nintegrate(exp(x), x, RischMethod())                 # exp(x)","category":"page"},{"location":"methods/risch/#Advanced-Cases","page":"Risch Method","title":"Advanced Cases","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"# Complex rational function with arctangent\nf = (3*x - 4*x^2 + 3*x^3)/(1 + x^2)\nintegrate(f, x, RischMethod())  # -4x + 4atan(x) + (3//2)*(x^2)\n\n# Integration by parts\nintegrate(log(x), x, RischMethod())  # -x + x*log(x)\n\n# Nested transcendental functions\nintegrate(1/(x*log(x)), x, RischMethod())  # log(log(x))","category":"page"},{"location":"methods/risch/#Method-Configuration","page":"Risch Method","title":"Method Configuration","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"# For research (strict error handling)\nresearch_risch = RischMethod(use_algebraic_closure=true, catch_errors=false)\n\n# For production (graceful error handling)\nproduction_risch = RischMethod(use_algebraic_closure=true, catch_errors=true)\n\n# For simple cases (faster computation)\nsimple_risch = RischMethod(use_algebraic_closure=false, catch_errors=true)","category":"page"},{"location":"methods/risch/#Algorithm-References","page":"Risch Method","title":"Algorithm References","text":"","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"The implementation follows:","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Manuel Bronstein: \"Symbolic Integration I: Transcendental Functions\", 2nd ed., Springer 2005\nChapter 1: General algorithms (polynomial operations, resultants)\nChapter 2: Rational function integration\nChapters 5-6: Transcendental function integration (Risch algorithm)\nAdditional chapters: Parametric problems, coupled systems","category":"page"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"This provides a complete, reference implementation of the Risch algorithm for elementary function integration.","category":"page"},{"location":"methods/risch_rational_functions/#Rational-Function-Integration","page":"Rational Function Integration","title":"Rational Function Integration","text":"","category":"section"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"SymbolicIntegration.jl implements the complete algorithm for integrating rational functions based on Bronstein's book Chapter 2.","category":"page"},{"location":"methods/risch_rational_functions/#Theory","page":"Rational Function Integration","title":"Theory","text":"","category":"section"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"A rational function is a quotient of polynomials:","category":"page"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"f(x) = P(x)/Q(x)","category":"page"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"The integration algorithm consists of three main steps:","category":"page"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"Hermite Reduction: Reduces the rational function to a simpler form\nLogarithmic Part: Finds the logarithmic terms using the Rothstein-Trager method\nPolynomial Part: Integrates any remaining polynomial terms","category":"page"},{"location":"methods/risch_rational_functions/#Examples","page":"Rational Function Integration","title":"Examples","text":"","category":"section"},{"location":"methods/risch_rational_functions/#Simple-Rational-Functions","page":"Rational Function Integration","title":"Simple Rational Functions","text":"","category":"section"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"using SymbolicIntegration, Symbolics\n@variables x\n\n# Linear over linear  \nintegrate((2*x + 3)/(x + 1), x)  # 2*x + log(1 + x)\n\n# Quadratic denominators\nintegrate(1/(x^2 + 1), x)        # atan(x)\nintegrate(x/(x^2 + 1), x)        # (1//2)*log(1 + x^2)","category":"page"},{"location":"methods/risch_rational_functions/#Partial-Fractions","page":"Rational Function Integration","title":"Partial Fractions","text":"","category":"section"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"The algorithm automatically handles partial fraction decomposition:","category":"page"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"# This gets decomposed into simpler fractions\nf = (x^3 + x^2 + x + 2)//(x^4 + 3*x^2 + 2)\nintegrate(f, x)  # (1//2)*log(2 + x^2) + atan(x)","category":"page"},{"location":"methods/risch_rational_functions/#Complex-Cases","page":"Rational Function Integration","title":"Complex Cases","text":"","category":"section"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"For cases involving complex roots, the algorithm uses the Rothstein-Trager method:","category":"page"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"# Denominator has complex roots\nf = (3*x - 4*x^2 + 3*x^3)/(1 + x^2)\nintegrate(f, x)  # -4*x + (3//2)*x^2 + 4*atan(x)","category":"page"},{"location":"methods/risch_rational_functions/#Algorithm-Details","page":"Rational Function Integration","title":"Algorithm Details","text":"","category":"section"},{"location":"methods/risch_rational_functions/#Hermite-Reduction","page":"Rational Function Integration","title":"Hermite Reduction","text":"","category":"section"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"# The HermiteReduce function is available for direct use\nusing SymbolicIntegration\nR, x = polynomial_ring(QQ, \"x\")\nA = 3*x^2 + 2*x + 1\nD = x^3 + x^2 + x + 1\ng, h = HermiteReduce(A, D)","category":"page"},{"location":"methods/risch_rational_functions/#Rothstein-Trager-Method","page":"Rational Function Integration","title":"Rothstein-Trager Method","text":"","category":"section"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"For finding logarithmic parts:","category":"page"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"# IntRationalLogPart implements the Rothstein-Trager algorithm\nlog_terms = IntRationalLogPart(A, D)","category":"page"},{"location":"methods/risch_rational_functions/#Limitations","page":"Rational Function Integration","title":"Limitations","text":"","category":"section"},{"location":"methods/risch_rational_functions/","page":"Rational Function Integration","title":"Rational Function Integration","text":"Only rational functions are supported (no algebraic functions like √x)\nResults are exact symbolic expressions\nPerformance may vary for very large polynomials","category":"page"},{"location":"manual/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"We welcome contributions!","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Below there are detailed info on how to contribute to the translation of new rules from the Mathematica RUBI package, or translation of solved integrals to use as tests, from the same package.","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Contributing to RuleBasedMethod\nCommon problems when translating rules\nfunction not translated\nSum function translation\nModule syntax translation\n* not present or present as [Star]\nDescription of the script src/translator_of_rules.jl\nHow to use it\nHow it works internally (useful to know if you have to debug it)\nWith syntax\nreplace and smart_replace applications\nPretty indentation\nend\nAdding Testsuites","category":"page"},{"location":"manual/contributing/#Contributing-to-translating-new-rules-for-RuleBasedMethod","page":"Contributing","title":"Contributing to translating new rules for RuleBasedMethod","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"In the github repo of the package there is also some software that serves the sole purpose of helping with the translation of rules from Mathematica syntax, and not for the actual package working. The important ones are:","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"translatorofrules.jl is a script that with regex and other string manipulations translates from Mathematica syntax to julia syntax (see \"houw to use it\" section later)\ntranslatoroftestset.jl is a script that translates the testsets into julia syntax (much simpler than translatorofrules.jl)\nreload_rules function in rules_loader.jl. When developing the package using Revise is not enough because rules are defined with a macro. So this function reloads rules from a specific .jl file or from all files if called without arguments.","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"my typical workflow is:","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"translate a rule file with translatorofrules.jl. In the resulting file there could be some problems:\nmaybe a Mathematica function that i never encountered before and therefore not included in the translation script (and in rulesutilityfunctions.jl)\nmaybe a Mathematica syntax that I never encountered before and not included in the translation script\nothers, see Common problems when translating rules\nIf the problem is quite common in other rules: implement in the translation script and translate the rule again, otherwise fix it manually in the .jl file","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"The rules not yet translated are mainly those from sections 4 to 8","category":"page"},{"location":"manual/contributing/#Common-problems-when-translating-rules","page":"Contributing","title":"Common problems when translating rules","text":"","category":"section"},{"location":"manual/contributing/#function-not-translated","page":"Contributing","title":"function not translated","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"If you encounter a normal function that is not translated by the script, it will stay untranslated, with square brackets, like this:","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"sqrt(Sign[(~b)]*sin((~e) + (~f)*(~x)))⨸sqrt((~d)*sin((~e) + (~f)*(~x)))* ∫(1⨸(sqrt((~a) + (~b)*sin((~e) + (~f)*(~x)))*sqrt(Sign[(~b)]*sin((~e) + (~f)*(~x)))), (~x)) : nothing)","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"a trick to find them fast is to search the regex pattern (?<=^[^#]).*\\[ in all the file. If you find them and they are already presen in julia or you implement them in rulesutilityfunctions.jl, you can simply add the to the smart_replace list in the translator and translate the script again.","category":"page"},{"location":"manual/contributing/#Sum-function-translation","page":"Contributing","title":"Sum function translation","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"the Sum[...] function gets translated with this regex:","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"(r\"Sum\\[(.*?),\\s*\\{(.*?),(.*?),(.*?)\\}\\]\", s\"sum([\\1 for \\2 in (\\3):(\\4)])\"), ","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"its quite common that the \\1 is a <=2 letter variable, and so will get translated from the translator into a slot variable, appending ~.","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"For example","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Sum[Int[1/(1 - Sin[e + f*x]^2/((-1)^(4*k/n)*Rt[-a/b, n/2])), x], {k, 1, n/2}]","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"gets translated to ","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"sum([∫(1⨸(1 - sin((~e) + (~f)*(~x))^2⨸((-1)^(4*(~k)⨸(~n))*rt(-(~a)⨸(~b), (~n)⨸2))), (~x)) for (~k) in ( 1):( (~n)⨸2)]","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"while it should be","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"sum([∫(1⨸(1 - sin((~e) + (~f)*(~x))^2⨸((-1)^(4*k⨸(~n))*rt(-(~a)⨸(~b), (~n)⨸2))), (~x)) for k in ( 1):( (~n)⨸2)]),","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"so what I usually do is to change the \"index of the summation\" variable to a >2 letters name in the Mathematica file, like this","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Sum[Int[1/(1 - Sin[e + f*x]^2/((-1)^(4*iii/n)*Rt[-a/b, n/2])), x], {iii, 1, n/2}]","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"so that will not be translated into slot variable.","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"sum([∫(1⨸(1 - sin((~e) + (~f)*(~x))^2⨸((-1)^(4*iii⨸(~n))*rt(-(~a)⨸(~b), (~n)⨸2))), (~x)) for iii in ( 1):( (~n)⨸2)]),","category":"page"},{"location":"manual/contributing/#Module-syntax-translation","page":"Contributing","title":"Module syntax translation","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"The Module Syntax is similar to the With syntax, but a bit different and for now is not handled by the script","category":"page"},{"location":"manual/contributing/#*-not-present-or-present-as-[Star]","page":"Contributing","title":"* not present or present as [Star]","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"in Mathematica if you write a b or a \\[Star] b is interpreted as a*b. So sometimes in the rules is written like that. When it happens i usually add the * in the mathematica file,  and then i translate it","category":"page"},{"location":"manual/contributing/#Description-of-the-script-src/translator_of_rules.jl","page":"Contributing","title":"Description of the script src/translator_of_rules.jl","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"This script is used to translate integration rules from Mathematica syntax to julia Syntax.","category":"page"},{"location":"manual/contributing/#How-to-use-it","page":"Contributing","title":"How to use it","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"In the branch rules of the github repo of the package there are all the Mathematica files containing the untranslated rules already in the correct folders in this repo, so that you can use the translator script like this:","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"julia src/translator_of_rules.jl \"src/rules/4 Trig functions/4.1 Sine/4.1.8 trig^m (a+b cos^p+c sin^q)^n.m\"","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"this will produce the julia file at the path src/rules/4 Trig functions/4.1 Sine/4.1.8 trig^m (a+b cos^p+c sin^q)^n.jl","category":"page"},{"location":"manual/contributing/#How-it-works-internally-(useful-to-know-if-you-have-to-debug-it)","page":"Contributing","title":"How it works internally (useful to know if you have to debug it)","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"It processes line per line, so the integration rule must be all on only one  line. Let's say we translate this (fictional) rule:","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Int[x_^m_./(a_ + b_. + c_.*x_^4), x_Symbol] := With[{q = Rt[a/c, 2], r = Rt[2*q - b/c, 2]}, 1/(2*c*r)*Int[x^(m - 3), x] - 1/(2*c*r) /; OddQ[r]] /; FreeQ[{a, b, c}, x] && (NeQ[b^2 - 4*a*c, 0] || (GeQ[m, 3] && LtQ[m, 4])) && NegQ[b^2 - 4*a*c]","category":"page"},{"location":"manual/contributing/#With-syntax","page":"Contributing","title":"With syntax","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"for each line it first check if there is the With syntax, a syntax in Mathematica that enables to define variables in a local scope. If yes it can do two things: In the new method translates the block using the let syntax, like this:","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"@rule ∫((~x)^(~!m)/((~a) + (~!b) + (~!c)*(~x)^4),(~x)) =>\n    !contains_var((~a), (~b), (~c), (~x)) &&\n    (\n        !eq((~b)^2 - 4*(~a)*(~c), 0) ||\n        (\n            ge((~m), 3) &&\n            lt((~m), 4)\n        )\n    ) &&\n    neg((~b)^2 - 4*(~a)*(~c)) ?\nlet\n    q = rt((~a)⨸(~c), 2)\n    r = rt(2*q - (~b)⨸(~c), 2)\n    \n    ext_isodd(r) ?\n    1⨸(2*(~c)*r)*∫((~x)^((~m) - 3), (~x)) - 1⨸(2*(~c)*r) : nothing\nend : nothing","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"The old method was to finds the defined variables and substitute them with their definition. Also there could be conditions inside the With block (OddQ in the example), that were bought outside.","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"1/(2*c*Rt[2*q - b/c, 2])*Int[x^(m - 3), x] - 1/(2*c*Rt[2*q - b/c, 2])/;  FreeQ[{a, b, c}, x] && (NeQ[b^2 - 4*a*c, 0] || (GeQ[m, 3] && LtQ[m, 4])) && NegQ[b^2 - 4*a*c] &&  OddQ[Rt[2*q - b/c, 2]]","category":"page"},{"location":"manual/contributing/#replace-and-smart_replace-applications","page":"Contributing","title":"replace and smart_replace applications","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Then the line is split into integral, result, and conditions:","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Int[x_^m_./(a_ + b_. + c_.*x_^4), x_Symbol]","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"1/(2*c*Rt[2*q - b/c, 2])*Int[x^(m - 3), x] - 1/(2*c*Rt[2*q - b/c, 2])","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"FreeQ[{a, b, c}, x] && (NeQ[b^2 - 4*a*c, 0] || (GeQ[m, 3] && LtQ[m, 4])) && NegQ[b^2 - 4*a*c] &&  OddQ[Rt[2*q - b/c, 2]]","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Each one of them is translated using the appropriate function, but the three all work the same. They first apply a number of times the smart_replace function, that replaces functions names without messing the nested brackets (like normal regex do)","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"smart_replace(\"ArcTan[Rt[b, 2]*x/Rt[a, 2]] + Log[x]\", \"ArcTan\", \"atan\")\n# output\n\"atan(Rt[b, 2]*x/Rt[a, 2]) + Log[x]\"","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Then also the normal replace function is applied a number of times, for more complex patterns. For example, every two letter word, optionally followed by  numbers, that is not a function call (so not followed by open parenthesis), and that is not the \"in\" word, is prefixed with a tilde ~. This is because in Mathematica you can reference the slot variables without any prefix, and in julia you need ~.","category":"page"},{"location":"manual/contributing/#Pretty-indentation","page":"Contributing","title":"Pretty indentation","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Then they are all put together following the julia rules syntax @rule integrand => conditions ? result : nothing","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"@rule ∫((~x)^(~!m)/((~a) + (~!b) + (~!c)*(~x)^4),(~x)) => !contains_var((~a), (~b), (~c), (~x)) && (!eq((~b)^2 - 4*(~a)*(~c), 0) || (ge((~m), 3) && lt((~m), 4))) && neg((~b)^2 - 4*(~a)*(~c)) && ext_isodd(rt(2*(~q) - (~b)/(~c), 2)) ? 1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2))*∫((~x)^((~m) - 3), (~x)) - 1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2)) : nothing","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"Usually the conditions are a lot of && and ||, so a pretty indentation is  applied automatically that rewrites the rule like this:","category":"page"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"@rule ∫((~x)^(~!m)/((~a) + (~!b) + (~!c)*(~x)^4),(~x)) =>\n    !contains_var((~a), (~b), (~c), (~x)) &&\n    (\n        !eq((~b)^2 - 4*(~a)*(~c), 0) ||\n        (\n            ge((~m), 3) &&\n            lt((~m), 4)\n        )\n    ) &&\n    neg((~b)^2 - 4*(~a)*(~c)) &&\n    ext_isodd(rt(2*(~q) - (~b)/(~c), 2)) ?\n1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2))*∫((~x)^((~m) - 3), (~x)) - 1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2)) : nothing","category":"page"},{"location":"manual/contributing/#end","page":"Contributing","title":"end","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"finally the rule is placed in a tuple (index, rule), and all the tuples are put into a array, ready to be included by load_rules","category":"page"},{"location":"manual/contributing/#Adding-Testsuites","page":"Contributing","title":"Adding Testsuites","text":"","category":"section"},{"location":"manual/contributing/","page":"Contributing","title":"Contributing","text":"There is a test suite of 27585 solved integrals taken from the RUBI package, in the folders test/test_files/0 Independent test suites (1796 tests) and test/test_files/1 Algebraic functions (25798 tests). But more test can be translated from the RUBI testsuite. In the branch rules of this repo there are the tests still in Mathematica syntax and a script to translate them to julia.","category":"page"},{"location":"manual/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial will help you get started with SymbolicIntegration.jl, covering installation, basic usage, and method selection.","category":"page"},{"location":"manual/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"Install SymbolicIntegration.jl from the Julia package registry:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"SymbolicIntegration\")","category":"page"},{"location":"manual/getting_started/#Basic-Setup","page":"Getting Started","title":"Basic Setup","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"To start using the package, import both SymbolicIntegration.jl and Symbolics.jl:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"using SymbolicIntegration, Symbolics\n\n# Define symbolic variables\n@variables x a b","category":"page"},{"location":"manual/getting_started/#Your-First-Integration","page":"Getting Started","title":"Your First Integration","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's start with some basic examples:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Basic polynomial\nintegrate(x^2, x)\n# Returns: (1//3)*(x^3)\n\n# Rational function\nintegrate(1/(x^2 + 1), x)\n# Returns: atan(x)\n\n# More complex rational function\nf = (x^3 + x^2 + x + 2)/(x^4 + 3*x^2 + 2)\nintegrate(f, x)\n# Returns: (1//2)*log(2 + x^2) + atan(x)","category":"page"},{"location":"manual/getting_started/#Transcendental-Functions","page":"Getting Started","title":"Transcendental Functions","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"SymbolicIntegration.jl handles exponential, logarithmic, and trigonometric functions:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Exponential functions\nintegrate(exp(x), x)        # Returns: exp(x)\nintegrate(x * exp(x), x)    # Returns: -exp(x) + x*exp(x)\n\n# Logarithmic functions  \nintegrate(log(x), x)        # Returns: -x + x*log(x)\nintegrate(1/(x*log(x)), x)  # Returns: log(log(x))\n\n# Trigonometric functions\nintegrate(sin(x), x)        # Returns: -cos(x)\nintegrate(cos(x), x)        # Returns: sin(x)","category":"page"},{"location":"manual/getting_started/#Method-Selection","page":"Getting Started","title":"Method Selection","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"SymbolicIntegration.jl provides two main integration methods that you can select explicitly:","category":"page"},{"location":"manual/getting_started/#Automatic-Method-Selection-(Default)","page":"Getting Started","title":"Automatic Method Selection (Default)","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"By default, the package automatically chooses the best method:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"f = (x^2 + 1)/(x^3 + x)\nintegrate(f, x)  # Automatically selects the best method","category":"page"},{"location":"manual/getting_started/#RischMethod","page":"Getting Started","title":"RischMethod","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"The Risch algorithm is based on Bronstein's \"Symbolic Integration I\" and provides exact algorithmic integration:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Basic usage\nintegrate(f, x, RischMethod())\n\n# With algebraic closure (for complex roots)\nintegrate(f, x, RischMethod(use_algebraic_closure=true))\n\n# With error catching\nintegrate(f, x, RischMethod(catch_errors=true))","category":"page"},{"location":"manual/getting_started/#RuleBasedMethod","page":"Getting Started","title":"RuleBasedMethod","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"The rule-based method uses pattern matching with a large database of integration rules:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Basic usage\nintegrate(f, x, RuleBasedMethod())\n\n# Verbose output (shows integration rules applied)\nintegrate(f, x, RuleBasedMethod(verbose=true))\n\n# Allow gamma functions in results\nintegrate(f, x, RuleBasedMethod(use_gamma=true))","category":"page"},{"location":"manual/getting_started/#Method-Comparison-Example","page":"Getting Started","title":"Method Comparison Example","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Compare methods on the same function\nf = sin(x)^2 * cos(x)\n\n# Risch method\nresult_risch = integrate(f, x, RischMethod())\n\n# Rule-based method\nresult_rules = integrate(f, x, RuleBasedMethod(verbose=false))\n\nprintln(\"Risch result: \", result_risch)\nprintln(\"Rule-based result: \", result_rules)","category":"page"},{"location":"manual/getting_started/#Error-Handling","page":"Getting Started","title":"Error Handling","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"Sometimes integration may fail or return unevaluated expressions:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# This integral has no elementary solution\ndifficult_f = exp(x^2)\n\ntry\n    result = integrate(difficult_f, x)\n    println(\"Result: \", result)\ncatch e\n    println(\"Integration failed: \", e)\nend\n\n# Use error catching options\nsafe_result = integrate(difficult_f, x, RischMethod(catch_errors=true))","category":"page"},{"location":"manual/getting_started/#Verification","page":"Getting Started","title":"Verification","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"You can verify integration results by differentiation:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"using Symbolics: Differential\n\n# Original function\nf = x^3 + 2*x^2 + x + 1\n\n# Integrate\nF = integrate(f, x)\n\n# Differentiate to verify\nD = Differential(x)\nf_check = expand_derivatives(D(F))\n\n# Check if they match\nsimplify(f - f_check) == 0  # Should be true","category":"page"},{"location":"manual/getting_started/#Common-Patterns","page":"Getting Started","title":"Common Patterns","text":"","category":"section"},{"location":"manual/getting_started/#Integration-by-Parts-(Automatic)","page":"Getting Started","title":"Integration by Parts (Automatic)","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# The algorithms handle integration by parts automatically\nintegrate(x * exp(x), x)    # Returns: -exp(x) + x*exp(x)\nintegrate(x * log(x), x)    # Uses integration by parts internally","category":"page"},{"location":"manual/getting_started/#Substitution-(Automatic)","page":"Getting Started","title":"Substitution (Automatic)","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Chain rule substitutions are handled automatically\nintegrate(sin(x^2) * x, x)  # Uses u = x^2 substitution\nintegrate(exp(x^2) * x, x)  # Returns: (1//2)*exp(x^2)","category":"page"},{"location":"manual/getting_started/#Partial-Fractions-(Automatic)","page":"Getting Started","title":"Partial Fractions (Automatic)","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Rational functions use partial fraction decomposition\nintegrate((x^2 + 1)/((x-1)*(x+1)), x)  # Automatically decomposes","category":"page"},{"location":"manual/getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now that you understand the basics:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"Explore the Integration Methods documentation for detailed algorithm explanations\nCheck the API Reference for complete function documentation\nSee the Risch Algorithm details for advanced usage","category":"page"},{"location":"manual/getting_started/#Common-Issues","page":"Getting Started","title":"Common Issues","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"Issue: Integration takes too long Solution: Try simplifying the expression first or switch methods:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"f_simplified = simplify(f)\nresult = integrate(f_simplified, x)\n# Or try the other method\nresult = integrate(f, x, RuleBasedMethod())","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"Issue: Method fails with error Solution: Try the alternative method or enable error catching:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"result = integrate(f, x, RischMethod(catch_errors=true))","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"Issue: Unexpected result form Solution: Simplify the result:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"result = integrate(f, x)\nsimplified_result = simplify(result)","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"(Image: Rules)","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"Usage\nConfiguration options\nHow it works internally\nProblems\nSerious\nMild\nMinor","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"This method uses a large number of integration rules that specify how to integrate various mathematical expressions. The rules were originally taken from the Mathematica package RUBI but later translated into julia.","category":"page"},{"location":"methods/rulebased/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"julia> integrate(sqrt(4 - 12*x + 9*x^2)+sqrt(1+x), x, RuleBasedMethod())\n┌-------Applied rule 0_1_0 on ∫(sqrt(1 + x) + sqrt(4 - 12x + 9(x^2)), x)\n| ∫( a + b + ..., x) => ∫(a,x) + ∫(b,x) + ...\n└-------with result: ∫(sqrt(4 - 12x + 9(x^2)), x) + ∫(sqrt(1 + x), x)\n┌-------Applied rule 1_1_1_1_4 on ∫(sqrt(1 + x), x)\n| ∫((a + b * x) ^ m, x) => if \n|       !(contains_var(a, b, m, x)) &&\n|       m !== -1\n| (a + b * x) ^ (m + 1) / (b * (m + 1))\n└-------with result: (2//3)*((1 + x)^(3//2))\n┌-------Applied rule 1_2_1_1_3 on ∫(sqrt(4 - 12x + 9(x^2)), x)\n| ∫((a + b * x + c * x ^ 2) ^ p, x) => if \n|       !(contains_var(a, b, c, p, x)) &&\n|       (\n|             b ^ 2 - 4 * a * c == 0 &&\n|             p !== -1 / 2\n|       )\n| ((b + 2 * c * x) * (a + b * x + c * x ^ 2) ^ p) / (2 * c * (2 * p + 1))\n└-------with result: (1//36)*(-12 + 18x)*((4 - 12x + 9(x^2))^(1//2))\n(2//3)*((1 + x)^(3//2)) + (1//36)*(-12 + 18x)*sqrt(4 - 12x + 9(x^2))","category":"page"},{"location":"methods/rulebased/#Configuration-options","page":"Usage","title":"Configuration options","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"verbose specifies whether to print or not the integration rules applied (default true)\nuse_gamma specifies whether to use rules with the gamma function in the result, or not (default false)","category":"page"},{"location":"methods/rulebased/#How-it-works-internally","page":"Usage","title":"How it works internally","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"The rules are defined using the SymbolicUtils rule macro and are of this form:","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"# rule 1_1_1_1_2\n@rule ∫((~x)^(~!m),(~x)) =>\n    !contains_var((~m), (~x)) &&\n    !eq((~m), -1) ?\n(~x)^((~m) + 1)⨸((~m) + 1) : nothing","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"The rule left hand side pattern is the symbolic function ∫(var1, var2) where first variable is the integrand and second is the integration variable. After the => there are some conditions to determine if the rules are applicable, and after the ? there is the transformation. Note that this may still contain a integral, so a walk in pre order of the tree representing the symbolic expression is done, applying rules to each node containing the integral.","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"The infix operator ⨸ is used to represent a custom division function, if called on integers returns a rational and if called on floats returns a float. This is done because // operator does not support floats. This specific character was chosen because it resembles the division symbol and because it has the same precedence as /.","category":"page"},{"location":"methods/rulebased/#Problems","page":"Usage","title":"Problems","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"Here are the problems holding back the most number of expressions to be integrated","category":"page"},{"location":"methods/rulebased/#Serious","page":"Usage","title":"Serious","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"Serious problems are problems that strongly impact the correct functioning of the rule based symbolic integrator and are difficult to fix. Here are the ones i encountered so far:","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"general rules for trigonometric functions: when integrating some expressions with trigonometric functions in Mathematica I see that strange rules are applied. Instead of the rule number \"General\" is showed, and they are strange because involve a level of pattern matching that is out of this world. For example integrating sin(x^2) the applied rule is F(tan(a + bx) where F gets automatically matched to exp(x^2/(1 + x^2). I mean is correct but how on earth could pattern matching know that...","category":"page"},{"location":"methods/rulebased/#neim-problem","page":"Usage","title":"neim problem","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"neim stands for negative exponents in multiplications","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"If I define a rule with this pattern @rule ((~!a) + (~!b)*(~x))^(~m)*((~!c) + (~!d)*(~x))^(~n)~)) it can correctly match something like (1+2x)^2 * (3+4x)^3. But when one of the two exponents is negative, let's say -3, this expression is represented in julia as (1+2x)^2 / (3+4x)^3). Or when both are negative, the expression is represented as 1 / ( (1+2x)^2 * (3+4x)^3 ). The matcher inside the rule instead, searches for a * as first operation, and thus doesn't recognize the expression. For this reason (1 + 3x)^2 / (1 + 2x)), (x^6) / (1 + 2(x^6)) and many other expressions dont get integrated. For more info you can read the issue or see this WIP pr in which i try to implement a solution.","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"A workaround I implemented is this:","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"julia> ins(expr) = SymbolicUtils.Term{Number}(^,[expr,-1])\nins (generic function with 1 method)\n\njulia> r = @rule (~n)/*(~d) => ~n*ins(~d)\n~n / (*)(~(~d)) => ~n * prod([ins(el) for el = ~(~d)])\n\njulia> r(a*b/(c*x))\na*b*(c^-1)*(x^-1)","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"creating a power with negative exponent, with Term and not with ^, doesnt autosimplify it to a division with positive exponent. So the rule can be applied. But is not good enough. here is a list of expressions not integrating due to this problem","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"log(x) / (x*sqrt(1 + log(x))) rule 315_36 \n1 / (x*sqrt(1 - (x^2))\nlog(1 - t) / (1 - t)\n(1 + x^2) / x","category":"page"},{"location":"methods/rulebased/#Mild","page":"Usage","title":"Mild","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"Mild problems are problems that impact the correct functioning of the rule based symbolic integrator and are medium difficulty to fix. Here are the ones I encountered so far:","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"ExpandIntegrand function: In the Mathematica package is defined the ExpandIntegrand function that expands a lot of mathematical expression (is defined in more than 360 rules of code) in strange ways. Some cases are been adderssed for now in the function ext_expand, but not all\nMaybe erorred tests: when testing, one checks that the integral is correct with isequal(simplify(computed_result  - real_result;expand=true), 0) but this doesnt always work. For example:","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"[fail]∫( (x^2)*sqrt(1 + x) )dx = \n  (2//3)*((1 + x)^(3//2)) - (4//5)*((1 + x)^(5//2)) + (2//7)*((1 + x)^(7//2)) but got:\n  -(4//7)*(-(2//3)*((1 + x)^(3//2)) + (2//5)*((1 + x)^(5//2))) + (2//7)*((1 + x)^(3//2))*(x^2)\n[fail]∫( (2^sqrt(x)) / sqrt(x) )dx = 1.4426950408889634(2^(1 + sqrt(x))) but got:\n      2.8853900817779268(2^(x^(1//2))) (0.2489s)","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"even tough the two are mathematically equivalent","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"strange behaviour with - sign:","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"julia> r = @rule (~a) + (~!b)*x => ~\n~a + ~(!b) * x => (~)\n\njulia> r(1+c*x)\nBase.ImmutableDict{Symbol, Any} with 4 entries:\n  :MATCH => 1 + c*x\n  :b     => c\n  :a     => 1\n  :____  => nothing\n\njulia> r(1-c*x)\n","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"because -c*x is represented as a three factor moltiplication between -1, c and x","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"integrals with complex numbers dont work very well","category":"page"},{"location":"methods/rulebased/#mild-problem:-oooomm","page":"Usage","title":"mild problem: oooomm","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"oooomm stands for only one out of multiple matches.","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"one rule can have more than one match. for example @rule ((~!a) + (~!b)*(~x))^(~m)*((~!c) + (~!d)*(~x))^(~n)~)) can match (1+2x)^2 * (3+4x)^3 with both m=2, n=3, ... or m=3, n=2, ... . Only one match of the possible ones is returned. but a usual rule form rubi is @rule pattern => if (conditions...) result else nothing. So first the pattern is found, but then if it doesnt match the conditions the rule returns nothing. But maybe one of the other possible matches matched the condition and the rule would have been applied. For more detail read the issue and see this WIP pr in which i try to implement a solution.","category":"page"},{"location":"methods/rulebased/#Example-in-intgeration","page":"Usage","title":"Example in intgeration","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"For example the problem presents itself in the following case. The rule is","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"(\"1_1_1_1_5\",\n@rule ∫(((~!a) + (~!b)*(~u))^(~m),(~x)) =>\n    !contains_var((~a), (~b), (~m), (~x)) &&\n    linear((~u), (~x)) &&\n    !eq((~u), (~x)) ?\n1⨸Symbolics.coeff((~u), (~x)^ 1)*int_and_subst(((~a) + (~b)*(~x))^(~m),  (~x), (~x), (~u), \"1_1_1_1_5\") : nothing)","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"and this works:","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"julia> integrate((1+a*(1+x))^2,x)\n((1 + a*(1 + x))^3) / (3a)","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"but doing this (now integration variable is a) doesnt:","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"julia> integrate((1+x*(1+a))^2,a)\nNo rule found for ∫((1 + (1 + a)*x)^2, a)","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"This is because in this new expression the matches are","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"~u matches x\n~!b matches 1+a","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"so the rule returns but then the condition linear(x, a) fails","category":"page"},{"location":"methods/rulebased/#another-example","page":"Usage","title":"another example","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"1/(sqrt(1+200x)*sqrt(2-x)) should integrate with the rule","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"(\"1_1_1_2_23\",\n@rule ∫(1/(sqrt((~!a) + (~!b)*(~x))*sqrt((~!c) + (~!d)*(~x))),(~x)) =>\n    !contains_var((~a), (~b), (~c), (~d), (~x)) &&\n    gt((~b)*(~c) - (~a)*(~d), 0) &&\n    gt((~b), 0) ?\n2⨸sqrt((~b))* int_and_subst(1⨸sqrt((~b)*(~c) - (~a)*(~d) + (~d)*(~x)^2), (~x), (~x), sqrt((~a) + (~b)*(~x)), \"1_1_1_2_23\") : nothing)","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"but the second condition is true only for 200*2 - 1*(-1) = 401 > 0 and not for (-1)*1 - 2*200 = -401 not > 0","category":"page"},{"location":"methods/rulebased/#Minor","page":"Usage","title":"Minor","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"in runtests, exp(x) is not recognized as ℯ^x. This is because integration produces a ℯ^x that doesnt get automatically translated into exp(x) like happens in the REPL\nroots of numbers are not treated simbolically but immediately calculated. So instead of the beautiful integrate(1/(sqrt(1+2x)*sqrt(3+4x))) = asinh(sqrt(2)*sqrt(1+2x))/sqrt(2), i have = 0.7071067811865475asinh(1.414213562373095sqrt(1 + 2x)). Or instead of integrate(2^x) = 2^x / log(2), i have integrate(2^x) = 1.4426950408889634*2^x. Or instead of integrate((2/sqrt(π))*exp(-x^2)) = SpecialFunctions.erf(x) I have  integrate((2/sqrt(π))*exp(-x^2)) = 0.9999999999999999SpecialFunctions.erf(x)\nthe variable USEGAMMA is used to choose if gamma function is used in the results or not. But right now is not configurable by the user, and if changed doesnt change the behaviour of th eintegration but a reloadrules() is needed, i dont know why.\nwhy here the coefficient is Inf ?","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"julia> integrate((3 + 4*x)^2.2/(1 + 2*x))\nNo rule found for ∫(((3 + 4x)^2.2) / (1 + 2x), x)\nintegration of ∫(((3 + 4x)^2.2) / (1 + 2x), x) failed, trying with this mathematically equivalent integrand:\n∫(((1 + 2x)^-1)*((3 + 4x)^2.2), x)\n┌-------Applied rule 1_1_1_2_37 on ∫(((1 + 2x)^-1)*((3 + 4x)^2.2), x)\n| ∫((a + b * x) ^ (m::!ext_isinteger) * (c + d * x) ^ (n::ext_isinteger), x) => if \n|       !(contains_var(a, b, c, d, m, x)) &&\n|       !(eq(b * c - a * d, 0))\n| (((b * c - a * d) ^ n * (a + b * x) ^ (m + 1)) / (b ^ (n + 1) * (m + 1))) * hypergeometric2f1(-n, m + 1, m + 2, (-d * (a + b * x)) / (b * c - a * d))\n└-------with result: Inf*SymbolicIntegration.hypergeometric2f1(-2.2, 0, 1, (-2//1)*(1 + 2x))\nInf*SymbolicIntegration.hypergeometric2f1(-2.2, 0, 1, (-2//1)*(1 + 2x))\n","category":"page"},{"location":"methods/rulebased/#Testing","page":"Usage","title":"Testing","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"There is a test suite of 27585 solved integrals taken from the RUBI package, in the folders test/test_files/0 Independent test suites (1796 tests) and test/test_files/1 Algebraic functions (25798 tests). They can be used to test the package running","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"julia --project=. test/runtests.jl","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"or in a Repl:","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"(@v1.11) pkg> activate .\n  Activating project at `~/.julia/dev/SymbolicIntegration.jl`\n\njulia> using Symbolics, SymbolicIntegration\n\njulia> include(\"test/runtests.jl\")\n","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"This will create a .out file with the test results. You can select which testests to test in the script test/runtests.jl.","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"To count how many tests are there you can use this command:","category":"page"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"find \"test/test_files/0 Independent test suites\" -type f -exec grep -c '^(' {} \\; | awk '{sum += $1} END {print \"Total matches:\", sum}' ","category":"page"},{"location":"methods/rulebased/#Contributing","page":"Usage","title":"Contributing","text":"","category":"section"},{"location":"methods/rulebased/","page":"Usage","title":"Usage","text":"see this docs page","category":"page"},{"location":"#SymbolicIntegration.jl","page":"Home","title":"SymbolicIntegration.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymbolicIntegration.jl lets you solve indefinite integrals (finds primitives) in Julia Symbolics.jl. It does so using two symbolic integration algorithms: Risch algorithm and Rule based algorithm.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"SymbolicIntegration\")","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using SymbolicIntegration, Symbolics\n\n@variables x a\n\n# Basic polynomial integration\nintegrate(x^2, x)  # Returns (1//3)*(x^3)\n\n# Rational function integration\nintegrate(1/(x^2 + 1), x)  # Returns atan(x)\nf = (x^3 + x^2 + x + 2)/(x^4 + 3*x^2 + 2)\nintegrate(f, x)  # Returns (1//2)*log(2 + x^2) + atan(x)\n\n# Transcendental functions\nintegrate(exp(x), x)    # Returns exp(x)\nintegrate(log(x), x)    # Returns -x + x*log(x)\n\n# Method selection and configuration\nintegrate(f, x, RischMethod())  # Explicit method choice\nintegrate(f, x, RischMethod(use_algebraic_closure=true))  # With options","category":"page"},{"location":"#Integration-Methods","page":"Home","title":"Integration Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymbolicIntegration.jl provides two integration algorithms: Rule based and Risch method. Here is a quick table to see what they can integrate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"feature Risch Rule based\nrational functions ✅ ✅\nnon integers powers ❌ ✅\nexponential functions ✅ ✅\nlogarithms ✅ ✅\ntrigonometric functions ? sometimes\nhyperbolic functions ✅ sometimes\nNonelementary integrals ❌ most of them\nSpecial functions ❌ ❌\nmultiple symbols ❌ ✅","category":"page"},{"location":"","page":"Home","title":"Home","text":"→ See complete methods documentation","category":"page"},{"location":"#RischMethod","page":"Home","title":"RischMethod","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This method is based on the algorithms from the book:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Manuel Bronstein, Symbolic Integration I: Transcentental Functions, 2nd ed, Springer 2005,","category":"page"},{"location":"","page":"Home","title":"Home","text":"for which a pretty complete set of reference implementations is provided. As in the book, integrands involving algebraic functions like sqrt and non-integer powers are not treated.","category":"page"},{"location":"","page":"Home","title":"Home","text":"integrate(x^2 + 1, x, RischMethod(use_algebraic_closure=false, catch_errors=true))","category":"page"},{"location":"","page":"Home","title":"Home","text":"use_algebraic_closure does what?\ncatch_errors does what?","category":"page"},{"location":"","page":"Home","title":"Home","text":"→ See detailed Risch documentation","category":"page"},{"location":"#RuleBased","page":"Home","title":"RuleBased","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This method uses a large number of integration rules that specify how to integrate various mathematical expressions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"integrate(x^2 + 1, x, RuleBasedMethod(verbose=true, use_gamma=false))","category":"page"},{"location":"","page":"Home","title":"Home","text":"verbose specifies whether to print or not the integration rules applied (default true)\nuse_gamma specifies whether to use rules with the gamma function in the result, or not (default false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"→ See detailed Rule based documentation","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We welcome contributions! Please see the contributing page and the Symbolics.jl contributing guidelines.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use SymbolicIntegration.jl in your research, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{SymbolicIntegration.jl,\n  author = {Harald Hofstätter and Mattia Micheletta Merlin and Chris Rackauckas},,\n  title = {SymbolicIntegration.jl: Symbolic Integration for Julia},\n  url = {https://github.com/JuliaSymbolics/SymbolicIntegration.jl},\n  year = {2023-2025}\n}","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"manual/contributing.md\",\n    \"api.md\"\n]\nDepth = 2","category":"page"},{"location":"methods/risch_transcendental_functions/#Transcendental-Function-Integration","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"SymbolicIntegration.jl implements the Risch algorithm for integrating elementary transcendental functions.","category":"page"},{"location":"methods/risch_transcendental_functions/#Supported-Functions","page":"Transcendental Function Integration","title":"Supported Functions","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/#Exponential-Functions","page":"Transcendental Function Integration","title":"Exponential Functions","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"using SymbolicIntegration, Symbolics\n@variables x\n\nintegrate(exp(x), x)        # exp(x)\nintegrate(exp(2*x), x)      # (1//2)*exp(2*x)\nintegrate(x*exp(x), x)      # -exp(x) + x*exp(x)","category":"page"},{"location":"methods/risch_transcendental_functions/#Logarithmic-Functions","page":"Transcendental Function Integration","title":"Logarithmic Functions","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"integrate(log(x), x)        # -x + x*log(x)\nintegrate(1/(x*log(x)), x)  # log(log(x))\nintegrate(log(x)^2, x)      # x*log(x)^2 - 2*x*log(x) + 2*x","category":"page"},{"location":"methods/risch_transcendental_functions/#Trigonometric-Functions","page":"Transcendental Function Integration","title":"Trigonometric Functions","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"Basic trigonometric functions are transformed to exponential form:","category":"page"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"integrate(sin(x), x)   # Transformed via half-angle formulas\nintegrate(cos(x), x)   # Transformed via half-angle formulas  \nintegrate(tan(x), x)   # Uses differential field extension","category":"page"},{"location":"methods/risch_transcendental_functions/#Hyperbolic-Functions","page":"Transcendental Function Integration","title":"Hyperbolic Functions","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"Hyperbolic functions are transformed to exponential form:","category":"page"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"integrate(sinh(x), x)  # Equivalent to (exp(x) - exp(-x))/2\nintegrate(cosh(x), x)  # Equivalent to (exp(x) + exp(-x))/2\nintegrate(tanh(x), x)  # Transformed to exponential form","category":"page"},{"location":"methods/risch_transcendental_functions/#Algorithm:-The-Risch-Method","page":"Transcendental Function Integration","title":"Algorithm: The Risch Method","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"The Risch algorithm builds a tower of differential fields to handle transcendental extensions systematically.","category":"page"},{"location":"methods/risch_transcendental_functions/#Differential-Field-Tower","page":"Transcendental Function Integration","title":"Differential Field Tower","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"For an integrand like exp(x^2) * log(x), the algorithm constructs:","category":"page"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"Base field: ℚ(x) with derivation d/dx\nFirst extension: ℚ(x, log(x)) with D(log(x)) = 1/x\nSecond extension: ℚ(x, log(x), exp(x^2)) with D(exp(x^2)) = 2*x*exp(x^2)","category":"page"},{"location":"methods/risch_transcendental_functions/#Integration-Steps","page":"Transcendental Function Integration","title":"Integration Steps","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"Field Tower Construction: Build the appropriate differential field tower\nCanonical Form: Transform the integrand to canonical form in the tower\nResidue Computation: Apply the Risch algorithm recursively\nResult Assembly: Convert back to symbolic form","category":"page"},{"location":"methods/risch_transcendental_functions/#Implementation-Details","page":"Transcendental Function Integration","title":"Implementation Details","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/#Function-Transformations","page":"Transcendental Function Integration","title":"Function Transformations","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"The algorithm transforms complex functions to simpler forms:","category":"page"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"Trigonometric functions → Half-angle formulas with tan(x/2)\nHyperbolic functions → Exponential expressions\nInverse functions → Differential field extensions","category":"page"},{"location":"methods/risch_transcendental_functions/#Example:-sin(x)-Integration","page":"Transcendental Function Integration","title":"Example: sin(x) Integration","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"# sin(x) is transformed to:\n# 2*tan(x/2) / (1 + tan(x/2)^2)\n# Then integrated using the Risch algorithm","category":"page"},{"location":"methods/risch_transcendental_functions/#Advanced-Usage","page":"Transcendental Function Integration","title":"Advanced Usage","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/#Direct-Algorithm-Access","page":"Transcendental Function Integration","title":"Direct Algorithm Access","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"You can access the lower-level algorithms directly:","category":"page"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"# Use the Risch algorithm directly\nusing SymbolicIntegration\n# ... (advanced example would go here)","category":"page"},{"location":"methods/risch_transcendental_functions/#Custom-Derivations","page":"Transcendental Function Integration","title":"Custom Derivations","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"# Create custom differential field extensions\n# ... (advanced example would go here)  ","category":"page"},{"location":"methods/risch_transcendental_functions/#Limitations","page":"Transcendental Function Integration","title":"Limitations","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/","page":"Transcendental Function Integration","title":"Transcendental Function Integration","text":"No algebraic functions (√x, x^(1/3), etc.)\nSome complex trigonometric cases may not be handled\nNon-elementary integrals return unevaluated forms","category":"page"}]
}
