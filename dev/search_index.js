var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Integration-Methods","page":"API Reference","title":"Integration Methods","text":"","category":"section"},{"location":"api/#Available-Methods","page":"API Reference","title":"Available Methods","text":"","category":"section"},{"location":"api/#SymbolicIntegration.integrate","page":"API Reference","title":"SymbolicIntegration.integrate","text":"integrate(f, x)\n\nintegrate function called without method. Compute the symbolic integral of expression f with respect to variable x using all available methods.\n\nArguments\n\nf: Symbolic expression to integrate (Symbolics.Num)\nx: Integration variable (Symbolics.Num)  \n\nExamples\n\njulia> using SymbolicIntegration, Symbolics\njulia> @variables x\njulia> integrate(2x)\nx^2\n\n\n\n\n\nintegrate(f::Symbolics.Num, method=nothing)\n\nintegrate function called without integration variable, and possibly without a method. If f contains only one symbolic variable, lets say x, calls integrate(f, x, method)\n\n\n\n\n\nintegrate(f, x, method::AbstractIntegrationMethod=RischMethod(); kwargs...)\n\nCompute the symbolic integral of expression f with respect to variable x  using Risch integration method.\n\nArguments\n\nf: Symbolic expression to integrate (Symbolics.Num)\nx: Integration variable (Symbolics.Num)  \n\nKeyword Arguments\n\nMethod-specific keyword arguments are passed to the method implementation\n\nReturns\n\nSymbolic expression representing the antiderivative (Symbolics.Num)\n\nExamples\n\n# Explicit method with options\nintegrate(1/(x^2 + 1), x, RischMethod(use_algebraic_closure=true))  # atan(x)\n\n# Method configuration\nrisch = RischMethod(use_algebraic_closure=false, catch_errors=true)\nintegrate(exp(x), x, risch)  # exp(x)\n\n\n\n\n\nintegrate(f, x, method::AbstractIntegrationMethod=RuleBasedMethod(); kwargs...)\n\nCompute the symbolic integral of expression f with respect to variable x using rule based method.\n\nArguments\n\nf: Symbolic expression to integrate (Symbolics.Num)\nx: Integration variable (Symbolics.Num)  \n\nReturns\n\nSymbolic expression representing the antiderivative (Symbolics.Num)\n\nExamples\n\njulia> integrate(1/sqrt(1 + x), x, RuleBasedMethod(verbose=true))\n┌-------Applied rule 1_1_2_1_33 (change of variables):\n| ∫((a + b * v ^ n) ^ p, x) => if \n|       !(contains_var(a, b, n, p, x)) &&\n|       (\n|             linear(v, x) &&\n|             v !== x\n|       )\n| (1 / ext_coeff(v, x, 1)) * substitute(∫{(a + b * x ^ n) ^ p}dx, x => v)\n└-------with result: ∫1 / (u^(1//2)) du where u = 1 + x\n┌-------Applied rule 1_1_1_1_2 on ∫(1 / (x^(1//2)), x)\n| ∫(x ^ m, x) => if \n|       !(contains_var(m, x)) &&\n|       m !== -1\n| x ^ (m + 1) / (m + 1)\n└-------with result: (2//1)*(x^(1//2))\n(2//1)*sqrt(1 + x)\n\njulia> rbm = RuleBasedMethod(verbose=false)\njulia> integrate(1/sqrt(1 + x), x, rbm)\n\n(2//1)*sqrt(1 + x)\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIntegration.RischMethod","page":"API Reference","title":"SymbolicIntegration.RischMethod","text":"RischMethod <: AbstractIntegrationMethod\n\nRisch algorithm for symbolic integration of elementary functions.\n\nFields\n\nuse_algebraic_closure::Bool: Whether to use algebraic closure for complex roots (default: true)\ncatch_errors::Bool: Whether to catch and handle algorithm errors gracefully (default: true)\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicIntegration.RuleBasedMethod","page":"API Reference","title":"SymbolicIntegration.RuleBasedMethod","text":"RuleBasedMethod <: AbstractIntegrationMethod\n\nuse_gamma::Bool: Whether to catch and handle algorithm errors gracefully (default: true)\nverbose::Bool: Whether to print or not integration rules applied (default: false)\n\n\n\n\n\n","category":"type"},{"location":"methods/overview/#Integration-Methods-Overview","page":"Integration Methods Overview","title":"Integration Methods Overview","text":"SymbolicIntegration.jl uses a flexible method dispatch system that allows you to choose different integration algorithms. Two methods are implemented:","category":"section"},{"location":"methods/overview/#RischMethod","page":"Integration Methods Overview","title":"RischMethod","text":"The Risch method is the complete algorithm for symbolic integration of elementary functions, based on Manuel Bronstein's algorithms.\n\n→ See detailed Risch documentation","category":"section"},{"location":"methods/overview/#Rule-based-method","page":"Integration Methods Overview","title":"Rule based method","text":"This method uses a large number of integration rules that specify how to integrate a vast class of mathematical expressions.\n\n→ See detailed Rule based documentation","category":"section"},{"location":"methods/risch/","page":"Risch Method","title":"Risch Method","text":"Risch Method\nOverview\nUsage\nConfiguration Options\nConstructor\nOptions\nuse_algebraic_closure::Bool (default: true)\ncatch_errors::Bool (default: true)\nAlgorithm Components\nRational Function Integration (Chapter 2)\nTranscendental Function Integration (Chapters 5-6)\nSupporting Algorithms\nFunction Classes Supported\nPolynomial Functions\nRational Functions\nExponential Functions\nLogarithmic Functions\nTrigonometric Functions\nLimitations\nPerformance Considerations\nWhen to Use Different Options\nComplexity\nExamples\nBasic Usage\nAdvanced Cases\nMethod Configuration\nAlgorithm References","category":"section"},{"location":"methods/risch/#Risch-Method","page":"Risch Method","title":"Risch Method","text":"The Risch method is a complete algorithm for symbolic integration of elementary functions. It implements the algorithms from Manuel Bronstein's \"Symbolic Integration I: Transcendental Functions\". Is implemented using AbstractAlgebra.jl and Nemo.jl.","category":"section"},{"location":"methods/risch/#Overview","page":"Risch Method","title":"Overview","text":"The Risch method is currently the primary integration method in SymbolicIntegration.jl. It provides exact symbolic integration for:\n\nRational functions: Using the Rothstein-Trager method\nExponential functions: Using differential field towers\nLogarithmic functions: Integration by parts and substitution\nTrigonometric functions: Transformation to exponential form\nComplex root handling: Exact arctangent terms","category":"section"},{"location":"methods/risch/#Usage","page":"Risch Method","title":"Usage","text":"using SymbolicIntegration, Symbolics\n@variables x\n\n# Explicit Risch method\nintegrate(1/(x^2 + 1), x, RischMethod())  # atan(x)\n\n# Risch method with options\nrisch = RischMethod(use_algebraic_closure=true, catch_errors=false)\nintegrate(f, x, risch)","category":"section"},{"location":"methods/risch/#Configuration-Options","page":"Risch Method","title":"Configuration Options","text":"","category":"section"},{"location":"methods/risch/#Constructor","page":"Risch Method","title":"Constructor","text":"RischMethod(; use_algebraic_closure=true, catch_errors=true)","category":"section"},{"location":"methods/risch/#Options","page":"Risch Method","title":"Options","text":"","category":"section"},{"location":"methods/risch/#use_algebraic_closure::Bool-(default:-true)","page":"Risch Method","title":"use_algebraic_closure::Bool (default: true)","text":"Controls whether the algorithm uses algebraic closure for finding complex roots.\n\ntrue: Finds complex roots, produces exact arctangent terms\nfalse: Only rational roots, faster for simple cases\n\n# With complex roots (produces atan terms)\nintegrate(1/(x^2 + 1), x, RischMethod(use_algebraic_closure=true))  # atan(x)\n\n# Without complex roots (may miss arctangent terms)  \nintegrate(1/(x^2 + 1), x, RischMethod(use_algebraic_closure=false))  # May return 0","category":"section"},{"location":"methods/risch/#catch_errors::Bool-(default:-true)","page":"Risch Method","title":"catch_errors::Bool (default: true)","text":"Controls error handling behavior.\n\ntrue: Returns unevaluated integrals for unsupported cases\nfalse: Throws exceptions for algorithmic failures\n\n# Graceful error handling\nintegrate(unsupported_function, x, RischMethod(catch_errors=true))  # Returns ∫(f, x)\n\n# Strict error handling  \nintegrate(unsupported_function, x, RischMethod(catch_errors=false))  # Throws exception","category":"section"},{"location":"methods/risch/#Algorithm-Components","page":"Risch Method","title":"Algorithm Components","text":"The Risch method implementation includes:","category":"section"},{"location":"methods/risch/#Rational-Function-Integration-(Chapter-2)","page":"Risch Method","title":"Rational Function Integration (Chapter 2)","text":"Hermite reduction: Simplifies rational functions\nRothstein-Trager method: Finds logarithmic parts\nPartial fraction decomposition: Handles complex denominators\nComplex root finding: Produces arctangent terms","category":"section"},{"location":"methods/risch/#Transcendental-Function-Integration-(Chapters-5-6)","page":"Risch Method","title":"Transcendental Function Integration (Chapters 5-6)","text":"Differential field towers: Handles nested transcendental functions\nRisch algorithm: Complete method for elementary functions\nPrimitive cases: Direct integration\nHyperexponential cases: Exponential function handling","category":"section"},{"location":"methods/risch/#Supporting-Algorithms","page":"Risch Method","title":"Supporting Algorithms","text":"Expression analysis: Converts symbolic expressions to algebraic form\nField extensions: Builds differential field towers\nRoot finding: Complex and rational root computation\nResult conversion: Transforms back to symbolic form","category":"section"},{"location":"methods/risch/#Function-Classes-Supported","page":"Risch Method","title":"Function Classes Supported","text":"","category":"section"},{"location":"methods/risch/#Polynomial-Functions","page":"Risch Method","title":"Polynomial Functions","text":"integrate(x^n, x)           # x^(n+1)/(n+1)\nintegrate(3*x^2 + 2*x + 1, x)  # x^3 + x^2 + x","category":"section"},{"location":"methods/risch/#Rational-Functions","page":"Risch Method","title":"Rational Functions","text":"integrate(1/x, x)               # log(x)\nintegrate(1/(x^2 + 1), x)       # atan(x)\nintegrate((x+1)/(x+2), x)       # x - log(2 + x)","category":"section"},{"location":"methods/risch/#Exponential-Functions","page":"Risch Method","title":"Exponential Functions","text":"integrate(exp(x), x)            # exp(x)\nintegrate(x*exp(x), x)          # -exp(x) + x*exp(x)\nintegrate(exp(x^2)*x, x)        # (1/2)*exp(x^2)","category":"section"},{"location":"methods/risch/#Logarithmic-Functions","page":"Risch Method","title":"Logarithmic Functions","text":"integrate(log(x), x)            # -x + x*log(x)\nintegrate(1/(x*log(x)), x)      # log(log(x))\nintegrate(log(x)^2, x)          # x*log(x)^2 - 2*x*log(x) + 2*x","category":"section"},{"location":"methods/risch/#Trigonometric-Functions","page":"Risch Method","title":"Trigonometric Functions","text":"integrate(sin(x), x)            # Transformed to exponential form\nintegrate(cos(x), x)            # Transformed to exponential form  \nintegrate(tan(x), x)            # Uses differential field extension","category":"section"},{"location":"methods/risch/#Limitations","page":"Risch Method","title":"Limitations","text":"The Risch method, following Bronstein's book, does not handle:\n\nAlgebraic functions: √x, x^(1/3), etc.\nNon-elementary functions: Functions without elementary antiderivatives\nSpecial functions: Bessel functions, hypergeometric functions, etc.\n\nFor these cases, the algorithm will:\n\nReturn unevaluated integrals if catch_errors=true\nThrow appropriate exceptions if catch_errors=false","category":"section"},{"location":"methods/risch/#Performance-Considerations","page":"Risch Method","title":"Performance Considerations","text":"","category":"section"},{"location":"methods/risch/#When-to-Use-Different-Options","page":"Risch Method","title":"When to Use Different Options","text":"Research/verification: catch_errors=false for strict algorithmic behavior\nProduction applications: catch_errors=true for robust operation\nComplex analysis: use_algebraic_closure=true for complete results\nSimple computations: use_algebraic_closure=false for faster execution","category":"section"},{"location":"methods/risch/#Complexity","page":"Risch Method","title":"Complexity","text":"Polynomial functions: O(n) where n is degree\nRational functions: Depends on degree and factorization complexity\nTranscendental functions: Exponential in tower height","category":"section"},{"location":"methods/risch/#Examples","page":"Risch Method","title":"Examples","text":"","category":"section"},{"location":"methods/risch/#Basic-Usage","page":"Risch Method","title":"Basic Usage","text":"@variables x\n\n# Simple cases\nintegrate(x^3, x, RischMethod())                    # (1//4)*(x^4)\nintegrate(1/x, x, RischMethod())                    # log(x)\nintegrate(exp(x), x, RischMethod())                 # exp(x)","category":"section"},{"location":"methods/risch/#Advanced-Cases","page":"Risch Method","title":"Advanced Cases","text":"# Complex rational function with arctangent\nf = (3*x - 4*x^2 + 3*x^3)/(1 + x^2)\nintegrate(f, x, RischMethod())  # -4x + 4atan(x) + (3//2)*(x^2)\n\n# Integration by parts\nintegrate(log(x), x, RischMethod())  # -x + x*log(x)\n\n# Nested transcendental functions\nintegrate(1/(x*log(x)), x, RischMethod())  # log(log(x))","category":"section"},{"location":"methods/risch/#Method-Configuration","page":"Risch Method","title":"Method Configuration","text":"# For research (strict error handling)\nresearch_risch = RischMethod(use_algebraic_closure=true, catch_errors=false)\n\n# For production (graceful error handling)\nproduction_risch = RischMethod(use_algebraic_closure=true, catch_errors=true)\n\n# For simple cases (faster computation)\nsimple_risch = RischMethod(use_algebraic_closure=false, catch_errors=true)","category":"section"},{"location":"methods/risch/#Algorithm-References","page":"Risch Method","title":"Algorithm References","text":"The implementation follows:\n\nManuel Bronstein: \"Symbolic Integration I: Transcendental Functions\", 2nd ed., Springer 2005\nChapter 1: General algorithms (polynomial operations, resultants)\nChapter 2: Rational function integration\nChapters 5-6: Transcendental function integration (Risch algorithm)\nAdditional chapters: Parametric problems, coupled systems\n\nThis provides a complete, reference implementation of the Risch algorithm for elementary function integration.","category":"section"},{"location":"methods/risch_rational_functions/#Rational-Function-Integration-with-Risch-algorithm","page":"Rational Function Integration with Risch algorithm","title":"Rational Function Integration with Risch algorithm","text":"SymbolicIntegration.jl implements the complete algorithm for integrating rational functions based on Bronstein's book Chapter 2.","category":"section"},{"location":"methods/risch_rational_functions/#Theory","page":"Rational Function Integration with Risch algorithm","title":"Theory","text":"A rational function is a quotient of polynomials:\n\nf(x) = P(x)/Q(x)\n\nThe integration algorithm consists of three main steps:\n\nHermite Reduction: Reduces the rational function to a simpler form\nLogarithmic Part: Finds the logarithmic terms using the Rothstein-Trager method\nPolynomial Part: Integrates any remaining polynomial terms","category":"section"},{"location":"methods/risch_rational_functions/#Examples","page":"Rational Function Integration with Risch algorithm","title":"Examples","text":"","category":"section"},{"location":"methods/risch_rational_functions/#Simple-Rational-Functions","page":"Rational Function Integration with Risch algorithm","title":"Simple Rational Functions","text":"using SymbolicIntegration, Symbolics\n@variables x\n\n# Linear over linear  \nintegrate((2*x + 3)/(x + 1), x)  # 2*x + log(1 + x)\n\n# Quadratic denominators\nintegrate(1/(x^2 + 1), x)        # atan(x)\nintegrate(x/(x^2 + 1), x)        # (1//2)*log(1 + x^2)","category":"section"},{"location":"methods/risch_rational_functions/#Partial-Fractions","page":"Rational Function Integration with Risch algorithm","title":"Partial Fractions","text":"The algorithm automatically handles partial fraction decomposition:\n\n# This gets decomposed into simpler fractions\nf = (x^3 + x^2 + x + 2)//(x^4 + 3*x^2 + 2)\nintegrate(f, x)  # (1//2)*log(2 + x^2) + atan(x)","category":"section"},{"location":"methods/risch_rational_functions/#Complex-Cases","page":"Rational Function Integration with Risch algorithm","title":"Complex Cases","text":"For cases involving complex roots, the algorithm uses the Rothstein-Trager method:\n\n# Denominator has complex roots\nf = (3*x - 4*x^2 + 3*x^3)/(1 + x^2)\nintegrate(f, x)  # -4*x + (3//2)*x^2 + 4*atan(x)","category":"section"},{"location":"methods/risch_rational_functions/#Algorithm-Details","page":"Rational Function Integration with Risch algorithm","title":"Algorithm Details","text":"","category":"section"},{"location":"methods/risch_rational_functions/#Hermite-Reduction","page":"Rational Function Integration with Risch algorithm","title":"Hermite Reduction","text":"# The HermiteReduce function is available for direct use\nusing SymbolicIntegration\nR, x = polynomial_ring(QQ, \"x\")\nA = 3*x^2 + 2*x + 1\nD = x^3 + x^2 + x + 1\ng, h = HermiteReduce(A, D)","category":"section"},{"location":"methods/risch_rational_functions/#Rothstein-Trager-Method","page":"Rational Function Integration with Risch algorithm","title":"Rothstein-Trager Method","text":"For finding logarithmic parts:\n\n# IntRationalLogPart implements the Rothstein-Trager algorithm\nlog_terms = IntRationalLogPart(A, D)","category":"section"},{"location":"methods/risch_rational_functions/#Limitations","page":"Rational Function Integration with Risch algorithm","title":"Limitations","text":"Only rational functions are supported (no algebraic functions like √x)\nResults are exact symbolic expressions\nPerformance may vary for very large polynomials","category":"section"},{"location":"manual/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"We welcome contributions!\n\nBelow there are detailed info on how to contribute to the translation of new rules from the Mathematica RUBI package, or translation of solved integrals to use as tests, from the same package.\n\nContributing to RuleBasedMethod\nCommon problems when translating rules\nfunction not translated\nSum function translation\nModule syntax translation\n* not present or present as [Star]\nDescription of the script src/translator_of_rules.jl\nHow to use it\nHow it works internally (useful to know if you have to debug it)\nWith syntax\nreplace and smart_replace applications\nPretty indentation\nend\nAdding Testsuites","category":"section"},{"location":"manual/contributing/#Contributing-to-translating-new-rules-for-RuleBasedMethod","page":"Contributing","title":"Contributing to translating new rules for RuleBasedMethod","text":"In the github repo of the package there is also some software that serves the sole purpose of helping with the translation of rules from Mathematica syntax, and not for the actual package working. The important ones are:\n\ntranslatorofrules.jl is a script that with regex and other string manipulations translates from Mathematica syntax to julia syntax (see \"houw to use it\" section later)\ntranslatoroftestset.jl is a script that translates the testsets into julia syntax (much simpler than translatorofrules.jl)\nreload_rules function in rules_loader.jl. When developing the package using Revise is not enough because rules are defined with a macro. So this function reloads rules from a specific .jl file or from all files if called without arguments.\n\nmy typical workflow is:\n\ntranslate a rule file with translatorofrules.jl. In the resulting file there could be some problems:\nmaybe a Mathematica function that i never encountered before and therefore not included in the translation script (and in rulesutilityfunctions.jl)\nmaybe a Mathematica syntax that I never encountered before and not included in the translation script\nothers, see Common problems when translating rules\nIf the problem is quite common in other rules: implement in the translation script and translate the rule again, otherwise fix it manually in the .jl file\n\nThe rules not yet translated are mainly those from sections 4 to 8","category":"section"},{"location":"manual/contributing/#Common-problems-when-translating-rules","page":"Contributing","title":"Common problems when translating rules","text":"","category":"section"},{"location":"manual/contributing/#function-not-translated","page":"Contributing","title":"function not translated","text":"If you encounter a normal function that is not translated by the script, it will stay untranslated, with square brackets, like this:\n\nsqrt(Sign[(~b)]*sin((~e) + (~f)*(~x)))⨸sqrt((~d)*sin((~e) + (~f)*(~x)))* ∫(1⨸(sqrt((~a) + (~b)*sin((~e) + (~f)*(~x)))*sqrt(Sign[(~b)]*sin((~e) + (~f)*(~x)))), (~x)) : nothing)\n\na trick to find them fast is to search the regex pattern (?<=^[^#]).*\\[ in all the file. If you find them and they are already presen in julia or you implement them in rulesutilityfunctions.jl, you can simply add the to the smart_replace list in the translator and translate the script again.","category":"section"},{"location":"manual/contributing/#Sum-function-translation","page":"Contributing","title":"Sum function translation","text":"the Sum[...] function gets translated with this regex:\n\n(r\"Sum\\[(.*?),\\s*\\{(.*?),(.*?),(.*?)\\}\\]\", s\"sum([\\1 for \\2 in (\\3):(\\4)])\"), \n\nits quite common that the \\1 is a <=2 letter variable, and so will get translated from the translator into a slot variable, appending ~.\n\nFor example\n\nSum[Int[1/(1 - Sin[e + f*x]^2/((-1)^(4*k/n)*Rt[-a/b, n/2])), x], {k, 1, n/2}]\n\ngets translated to \n\nsum([∫(1⨸(1 - sin((~e) + (~f)*(~x))^2⨸((-1)^(4*(~k)⨸(~n))*rt(-(~a)⨸(~b), (~n)⨸2))), (~x)) for (~k) in ( 1):( (~n)⨸2)]\n\nwhile it should be\n\nsum([∫(1⨸(1 - sin((~e) + (~f)*(~x))^2⨸((-1)^(4*k⨸(~n))*rt(-(~a)⨸(~b), (~n)⨸2))), (~x)) for k in ( 1):( (~n)⨸2)]),\n\nso what I usually do is to change the \"index of the summation\" variable to a >2 letters name in the Mathematica file, like this\n\nSum[Int[1/(1 - Sin[e + f*x]^2/((-1)^(4*iii/n)*Rt[-a/b, n/2])), x], {iii, 1, n/2}]\n\nso that will not be translated into slot variable.\n\nsum([∫(1⨸(1 - sin((~e) + (~f)*(~x))^2⨸((-1)^(4*iii⨸(~n))*rt(-(~a)⨸(~b), (~n)⨸2))), (~x)) for iii in ( 1):( (~n)⨸2)]),","category":"section"},{"location":"manual/contributing/#Module-syntax-translation","page":"Contributing","title":"Module syntax translation","text":"The Module Syntax is similar to the With syntax, but a bit different and for now is not handled by the script","category":"section"},{"location":"manual/contributing/#*-not-present-or-present-as-[Star]","page":"Contributing","title":"* not present or present as [Star]","text":"in Mathematica if you write a b or a \\[Star] b is interpreted as a*b. So sometimes in the rules is written like that. When it happens i usually add the * in the mathematica file,  and then i translate it","category":"section"},{"location":"manual/contributing/#Description-of-the-script-src/translator_of_rules.jl","page":"Contributing","title":"Description of the script src/translator_of_rules.jl","text":"This script is used to translate integration rules from Mathematica syntax to julia Syntax.","category":"section"},{"location":"manual/contributing/#How-to-use-it","page":"Contributing","title":"How to use it","text":"In the branch rules of the github repo of the package there are all the Mathematica files containing the untranslated rules already in the correct folders in this repo, so that you can use the translator script like this:\n\njulia src/translator_of_rules.jl \"src/rules/4 Trig functions/4.1 Sine/4.1.8 trig^m (a+b cos^p+c sin^q)^n.m\"\n\nthis will produce the julia file at the path src/rules/4 Trig functions/4.1 Sine/4.1.8 trig^m (a+b cos^p+c sin^q)^n.jl","category":"section"},{"location":"manual/contributing/#How-it-works-internally-(useful-to-know-if-you-have-to-debug-it)","page":"Contributing","title":"How it works internally (useful to know if you have to debug it)","text":"It processes line per line, so the integration rule must be all on only one  line. Let's say we translate this (fictional) rule:\n\nInt[x_^m_./(a_ + b_. + c_.*x_^4), x_Symbol] := With[{q = Rt[a/c, 2], r = Rt[2*q - b/c, 2]}, 1/(2*c*r)*Int[x^(m - 3), x] - 1/(2*c*r) /; OddQ[r]] /; FreeQ[{a, b, c}, x] && (NeQ[b^2 - 4*a*c, 0] || (GeQ[m, 3] && LtQ[m, 4])) && NegQ[b^2 - 4*a*c]","category":"section"},{"location":"manual/contributing/#With-syntax","page":"Contributing","title":"With syntax","text":"for each line it first check if there is the With syntax, a syntax in Mathematica that enables to define variables in a local scope. If yes it can do two things: In the new method translates the block using the let syntax, like this:\n\n@rule ∫((~x)^(~!m)/((~a) + (~!b) + (~!c)*(~x)^4),(~x)) =>\n    !contains_var((~a), (~b), (~c), (~x)) &&\n    (\n        !eq((~b)^2 - 4*(~a)*(~c), 0) ||\n        (\n            ge((~m), 3) &&\n            lt((~m), 4)\n        )\n    ) &&\n    neg((~b)^2 - 4*(~a)*(~c)) ?\nlet\n    q = rt((~a)⨸(~c), 2)\n    r = rt(2*q - (~b)⨸(~c), 2)\n    \n    ext_isodd(r) ?\n    1⨸(2*(~c)*r)*∫((~x)^((~m) - 3), (~x)) - 1⨸(2*(~c)*r) : nothing\nend : nothing\n\nThe old method was to finds the defined variables and substitute them with their definition. Also there could be conditions inside the With block (OddQ in the example), that were bought outside.\n\n1/(2*c*Rt[2*q - b/c, 2])*Int[x^(m - 3), x] - 1/(2*c*Rt[2*q - b/c, 2])/;  FreeQ[{a, b, c}, x] && (NeQ[b^2 - 4*a*c, 0] || (GeQ[m, 3] && LtQ[m, 4])) && NegQ[b^2 - 4*a*c] &&  OddQ[Rt[2*q - b/c, 2]]","category":"section"},{"location":"manual/contributing/#replace-and-smart_replace-applications","page":"Contributing","title":"replace and smart_replace applications","text":"Then the line is split into integral, result, and conditions:\n\nInt[x_^m_./(a_ + b_. + c_.*x_^4), x_Symbol]\n\n1/(2*c*Rt[2*q - b/c, 2])*Int[x^(m - 3), x] - 1/(2*c*Rt[2*q - b/c, 2])\n\nFreeQ[{a, b, c}, x] && (NeQ[b^2 - 4*a*c, 0] || (GeQ[m, 3] && LtQ[m, 4])) && NegQ[b^2 - 4*a*c] &&  OddQ[Rt[2*q - b/c, 2]]\n\nEach one of them is translated using the appropriate function, but the three all work the same. They first apply a number of times the smart_replace function, that replaces functions names without messing the nested brackets (like normal regex do)\n\nsmart_replace(\"ArcTan[Rt[b, 2]*x/Rt[a, 2]] + Log[x]\", \"ArcTan\", \"atan\")\n# output\n\"atan(Rt[b, 2]*x/Rt[a, 2]) + Log[x]\"\n\nThen also the normal replace function is applied a number of times, for more complex patterns. For example, every two letter word, optionally followed by  numbers, that is not a function call (so not followed by open parenthesis), and that is not the \"in\" word, is prefixed with a tilde ~. This is because in Mathematica you can reference the slot variables without any prefix, and in julia you need ~.","category":"section"},{"location":"manual/contributing/#Pretty-indentation","page":"Contributing","title":"Pretty indentation","text":"Then they are all put together following the julia rules syntax @rule integrand => conditions ? result : nothing\n\n@rule ∫((~x)^(~!m)/((~a) + (~!b) + (~!c)*(~x)^4),(~x)) => !contains_var((~a), (~b), (~c), (~x)) && (!eq((~b)^2 - 4*(~a)*(~c), 0) || (ge((~m), 3) && lt((~m), 4))) && neg((~b)^2 - 4*(~a)*(~c)) && ext_isodd(rt(2*(~q) - (~b)/(~c), 2)) ? 1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2))*∫((~x)^((~m) - 3), (~x)) - 1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2)) : nothing\n\nUsually the conditions are a lot of && and ||, so a pretty indentation is  applied automatically that rewrites the rule like this:\n\n@rule ∫((~x)^(~!m)/((~a) + (~!b) + (~!c)*(~x)^4),(~x)) =>\n    !contains_var((~a), (~b), (~c), (~x)) &&\n    (\n        !eq((~b)^2 - 4*(~a)*(~c), 0) ||\n        (\n            ge((~m), 3) &&\n            lt((~m), 4)\n        )\n    ) &&\n    neg((~b)^2 - 4*(~a)*(~c)) &&\n    ext_isodd(rt(2*(~q) - (~b)/(~c), 2)) ?\n1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2))*∫((~x)^((~m) - 3), (~x)) - 1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2)) : nothing","category":"section"},{"location":"manual/contributing/#end","page":"Contributing","title":"end","text":"finally the rule is placed in a tuple (index, rule), and all the tuples are put into a array, ready to be included by load_rules","category":"section"},{"location":"manual/contributing/#Adding-Testsuites","page":"Contributing","title":"Adding Testsuites","text":"There is a test suite of 27585 solved integrals taken from the RUBI package, in the folders test/test_files/0 Independent test suites (1796 tests) and test/test_files/1 Algebraic functions (25798 tests). But more test can be translated from the RUBI testsuite. In the branch rules of this repo there are the tests still in Mathematica syntax and a script to translate them to julia.","category":"section"},{"location":"manual/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This tutorial will help you get started with SymbolicIntegration.jl, covering installation, basic usage, and method selection.","category":"section"},{"location":"manual/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"Install SymbolicIntegration.jl from the Julia package registry:\n\nusing Pkg\nPkg.add(\"SymbolicIntegration\")","category":"section"},{"location":"manual/getting_started/#Basic-Setup","page":"Getting Started","title":"Basic Setup","text":"To start using the package, import both SymbolicIntegration.jl and Symbolics.jl:\n\nusing SymbolicIntegration, Symbolics\n\n# Define symbolic variables\n@variables x a b","category":"section"},{"location":"manual/getting_started/#Your-First-Integration","page":"Getting Started","title":"Your First Integration","text":"Let's start with some basic examples:\n\n# Basic polynomial\nintegrate(x^2, x)\n# Returns: (1//3)*(x^3)\n\n# Rational function\nintegrate(1/(x^2 + 1), x)\n# Returns: atan(x)\n\n# More complex rational function\nf = (x^3 + x^2 + x + 2)/(x^4 + 3*x^2 + 2)\nintegrate(f, x)\n# Returns: (1//2)*log(2 + x^2) + atan(x)","category":"section"},{"location":"manual/getting_started/#Transcendental-Functions","page":"Getting Started","title":"Transcendental Functions","text":"SymbolicIntegration.jl handles exponential, logarithmic, and trigonometric functions:\n\n# Exponential functions\nintegrate(exp(x), x)        # Returns: exp(x)\nintegrate(x * exp(x), x)    # Returns: -exp(x) + x*exp(x)\n\n# Logarithmic functions  \nintegrate(log(x), x)        # Returns: -x + x*log(x)\nintegrate(1/(x*log(x)), x)  # Returns: log(log(x))\n\n# Trigonometric functions\nintegrate(sin(x), x)        # Returns: -cos(x)\nintegrate(cos(x), x)        # Returns: sin(x)","category":"section"},{"location":"manual/getting_started/#Method-Selection","page":"Getting Started","title":"Method Selection","text":"SymbolicIntegration.jl provides two main integration methods that you can select explicitly:","category":"section"},{"location":"manual/getting_started/#Automatic-Method-Selection-(Default)","page":"Getting Started","title":"Automatic Method Selection (Default)","text":"By default, the package automatically chooses the best method:\n\nf = (x^2 + 1)/(x^3 + x)\nintegrate(f, x)  # Automatically selects the best method","category":"section"},{"location":"manual/getting_started/#RischMethod","page":"Getting Started","title":"RischMethod","text":"The Risch algorithm is based on Bronstein's \"Symbolic Integration I\" and provides exact algorithmic integration:\n\n# Basic usage\nintegrate(f, x, RischMethod())\n\n# With algebraic closure (for complex roots)\nintegrate(f, x, RischMethod(use_algebraic_closure=true))\n\n# With error catching\nintegrate(f, x, RischMethod(catch_errors=true))","category":"section"},{"location":"manual/getting_started/#RuleBasedMethod","page":"Getting Started","title":"RuleBasedMethod","text":"The rule-based method uses pattern matching with a large database of integration rules:\n\n# Basic usage\nintegrate(f, x, RuleBasedMethod())\n\n# Verbose output (shows integration rules applied)\nintegrate(f, x, RuleBasedMethod(verbose=true))\n\n# Allow gamma functions in results\nintegrate(f, x, RuleBasedMethod(use_gamma=true))","category":"section"},{"location":"manual/getting_started/#Method-Comparison-Example","page":"Getting Started","title":"Method Comparison Example","text":"# Compare methods on the same function\nf = sin(x)^2 * cos(x)\n\n# Risch method\nresult_risch = integrate(f, x, RischMethod())\n\n# Rule-based method\nresult_rules = integrate(f, x, RuleBasedMethod(verbose=false))\n\nprintln(\"Risch result: \", result_risch)\nprintln(\"Rule-based result: \", result_rules)","category":"section"},{"location":"manual/getting_started/#Error-Handling","page":"Getting Started","title":"Error Handling","text":"Sometimes integration may fail or return unevaluated expressions:\n\n# This integral has no elementary solution\ndifficult_f = exp(x^2)\n\ntry\n    result = integrate(difficult_f, x)\n    println(\"Result: \", result)\ncatch e\n    println(\"Integration failed: \", e)\nend\n\n# Use error catching options\nsafe_result = integrate(difficult_f, x, RischMethod(catch_errors=true))","category":"section"},{"location":"manual/getting_started/#Verification","page":"Getting Started","title":"Verification","text":"You can verify integration results by differentiation:\n\nusing Symbolics: Differential\n\n# Original function\nf = x^3 + 2*x^2 + x + 1\n\n# Integrate\nF = integrate(f, x)\n\n# Differentiate to verify\nD = Differential(x)\nf_check = expand_derivatives(D(F))\n\n# Check if they match\nsimplify(f - f_check) == 0  # Should be true","category":"section"},{"location":"manual/getting_started/#Common-Patterns","page":"Getting Started","title":"Common Patterns","text":"","category":"section"},{"location":"manual/getting_started/#Integration-by-Parts-(Automatic)","page":"Getting Started","title":"Integration by Parts (Automatic)","text":"# The algorithms handle integration by parts automatically\nintegrate(x * exp(x), x)    # Returns: -exp(x) + x*exp(x)\nintegrate(x * log(x), x)    # Uses integration by parts internally","category":"section"},{"location":"manual/getting_started/#Substitution-(Automatic)","page":"Getting Started","title":"Substitution (Automatic)","text":"# Chain rule substitutions are handled automatically\nintegrate(sin(x^2) * x, x)  # Uses u = x^2 substitution\nintegrate(exp(x^2) * x, x)  # Returns: (1//2)*exp(x^2)","category":"section"},{"location":"manual/getting_started/#Partial-Fractions-(Automatic)","page":"Getting Started","title":"Partial Fractions (Automatic)","text":"# Rational functions use partial fraction decomposition\nintegrate((x^2 + 1)/((x-1)*(x+1)), x)  # Automatically decomposes","category":"section"},{"location":"manual/getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Now that you understand the basics:\n\nExplore the Integration Methods documentation for detailed algorithm explanations\nCheck the API Reference for complete function documentation\nSee the Risch Algorithm details for advanced usage","category":"section"},{"location":"manual/getting_started/#Common-Issues","page":"Getting Started","title":"Common Issues","text":"Issue: Integration takes too long Solution: Try simplifying the expression first or switch methods:\n\nf_simplified = simplify(f)\nresult = integrate(f_simplified, x)\n# Or try the other method\nresult = integrate(f, x, RuleBasedMethod())\n\nIssue: Method fails with error Solution: Try the alternative method or enable error catching:\n\nresult = integrate(f, x, RischMethod(catch_errors=true))\n\nIssue: Unexpected result form Solution: Simplify the result:\n\nresult = integrate(f, x)\nsimplified_result = simplify(result)","category":"section"},{"location":"methods/rulebased/","page":"Rule based method","title":"Rule based method","text":"(Image: Rules)\n\nRule based method\nConfiguration options\nHow it works internally\nRules statistic\nProblems\nSerious\nMild\nMinor\nTesting\nContributing","category":"section"},{"location":"methods/rulebased/#Rule-based-method","page":"Rule based method","title":"Rule based method","text":"This method uses a large number of integration rules that specify how to integrate various mathematical expressions. The rules were originally taken from the Mathematica package RUBI but later translated into julia.\n\njulia> integrate(sqrt(4 - 12*x + 9*x^2)+sqrt(1+x), RuleBasedMethod(verbose=true))\n┌-------Applied rule 0_1_0 on ∫(sqrt(1 + x) + sqrt(4 - 12x + 9(x^2)), x)\n| ∫( a + b + ..., x) => ∫(a,x) + ∫(b,x) + ...\n└-------with result: ∫(sqrt(4 - 12x + 9(x^2)), x) + ∫(sqrt(1 + x), x)\n┌-------Applied rule 1_1_1_1_4 on ∫(sqrt(1 + x), x)\n| ∫((a + b * x) ^ m, x) => if \n|       !(contains_var(a, b, m, x)) &&\n|       m !== -1\n| (a + b * x) ^ (m + 1) / (b * (m + 1))\n└-------with result: (2//3)*((1 + x)^(3//2))\n┌-------Applied rule 1_2_1_1_3 on ∫(sqrt(4 - 12x + 9(x^2)), x)\n| ∫((a + b * x + c * x ^ 2) ^ p, x) => if \n|       !(contains_var(a, b, c, p, x)) &&\n|       (\n|             b ^ 2 - 4 * a * c == 0 &&\n|             p !== -1 / 2\n|       )\n| ((b + 2 * c * x) * (a + b * x + c * x ^ 2) ^ p) / (2 * c * (2 * p + 1))\n└-------with result: (1//36)*(-12 + 18x)*((4 - 12x + 9(x^2))^(1//2))\n(2//3)*((1 + x)^(3//2)) + (1//36)*(-12 + 18x)*sqrt(4 - 12x + 9(x^2))\n\njulia> rbm = RuleBasedMethod(verbose=false)\njulia> integrate(1/sqrt(1 + x), x, rbm)\n(2//1)*sqrt(1 + x)","category":"section"},{"location":"methods/rulebased/#Configuration-options","page":"Rule based method","title":"Configuration options","text":"verbose specifies whether to print or not the integration rules applied (really helpful)\nuse_gamma specifies whether to use rules with the gamma function in the result, or not (default false)","category":"section"},{"location":"methods/rulebased/#How-it-works-internally","page":"Rule based method","title":"How it works internally","text":"The rules are defined as Pair of Exprs and are of this form:\n\n# rule 1_1_1_1_2\n:(∫((~x)^(~!m),(~x))) => :(\n    !contains_var((~m), (~x)) &&\n    !eq((~m), -1) ?\n(~x)^((~m) + 1)⨸((~m) + 1) : nothing)\n\nThe rule left hand side pattern is the symbolic function ∫(var1, var2) where first variable is the integrand and second is the integration variable. After the => there are some conditions to determine if the rules are applicable, and after the ? there is the transformation. Note that this may still contain a integral, so a walk in pre order of the tree representing the symbolic expression is done, applying rules to each node containing the integral.\n\nThe infix operator ⨸ is used to represent a custom division function, if called on integers returns a rational and if called on floats returns a float. This is done because // operator does not support floats. This specific character was chosen because it resembles the division symbol and because it has the same precedence as /.","category":"section"},{"location":"methods/rulebased/#Rules-statistic","page":"Rule based method","title":"Rules statistic","text":"Default is deactivated but its possible to activate that every time a rule gets applied on a expression it gets saved to a txt file (test/statistics/rules_statistics.txt) for continug which rules are actually used. to elaborate the file you can run from the home folder of the package\n\njulia --project=. test/statistics/elaborate_statistics.jl \n\nthis will generate test/statistics/rules_statistics_elaborated.txt","category":"section"},{"location":"methods/rulebased/#Problems","page":"Rule based method","title":"Problems","text":"Here are the problems holding back the most number of expressions to be integrated","category":"section"},{"location":"methods/rulebased/#Serious","page":"Rule based method","title":"Serious","text":"Serious problems are problems that strongly impact the correct functioning of the rule based symbolic integrator and are difficult to fix. Here are the ones i encountered so far:\n\ngeneral rules for trigonometric functions: when integrating some expressions with trigonometric functions in Mathematica I see that strange rules are applied. Instead of the rule number \"General\" is showed, and they are strange because involve a level of pattern matching that is out of this world. For example integrating sin(x^2) the applied rule is F(tan(a + bx) where F gets automatically matched to exp(x^2/(1 + x^2). I mean is correct but how on earth could pattern matching know that...","category":"section"},{"location":"methods/rulebased/#Mild","page":"Rule based method","title":"Mild","text":"Mild problems are problems that impact the correct functioning of the rule based symbolic integrator and are medium difficulty to fix. Here are the ones I encountered so far:\n\nExpandIntegrand function: In the Mathematica package is defined the ExpandIntegrand function that expands a lot of mathematical expression (is defined in more than 360 rules of code) in strange ways. Some cases are been adderssed for now in the function ext_expand, but not all\nMaybe erorred tests: when testing, one checks that the integral is correct with isequal(simplify(computed_result  - real_result;expand=true), 0) but this doesnt always work. For example:\n\n[fail]∫( (x^2)*sqrt(1 + x) )dx = \n  (2//3)*((1 + x)^(3//2)) - (4//5)*((1 + x)^(5//2)) + (2//7)*((1 + x)^(7//2)) but got:\n  -(4//7)*(-(2//3)*((1 + x)^(3//2)) + (2//5)*((1 + x)^(5//2))) + (2//7)*((1 + x)^(3//2))*(x^2)\n[fail]∫( (2^sqrt(x)) / sqrt(x) )dx = 1.4426950408889634(2^(1 + sqrt(x))) but got:\n      2.8853900817779268(2^(x^(1//2))) (0.2489s)\n\neven tough the two are mathematically equivalent\n\nstrange behaviour with - sign:\n\njulia> r = @rule (~a) + (~!b)*x => ~\n~a + ~(!b) * x => (~)\n\njulia> r(1+c*x)\nBase.ImmutableDict{Symbol, Any} with 4 entries:\n  :MATCH => 1 + c*x\n  :b     => c\n  :a     => 1\n  :____  => nothing\n\njulia> r(1-c*x)\n\n\nbecause -c*x is represented as a three factor moltiplication between -1, c and x\n\nintegrals with complex numbers dont work very well","category":"section"},{"location":"methods/rulebased/#mild-problem:-oooomm","page":"Rule based method","title":"mild problem: oooomm","text":"oooomm stands for only one out of multiple matches.\n\none rule can have more than one match. for example @rule ((~!a) + (~!b)*(~x))^(~m)*((~!c) + (~!d)*(~x))^(~n)~)) can match (1+2x)^2 * (3+4x)^3 with both m=2, n=3, ... or m=3, n=2, ... . Only one match of the possible ones is returned. but a usual rule form rubi is @rule pattern => if (conditions...) result else nothing. So first the pattern is found, but then if it doesnt match the conditions the rule returns nothing. But maybe one of the other possible matches matched the condition and the rule would have been applied. For more detail read the issue and see this WIP pr in which i try to implement a solution.","category":"section"},{"location":"methods/rulebased/#Example-in-intgeration","page":"Rule based method","title":"Example in intgeration","text":"For example the problem presents itself in the following case. The rule is\n\n(\"1_1_1_1_5\",\n@rule ∫(((~!a) + (~!b)*(~u))^(~m),(~x)) =>\n    !contains_var((~a), (~b), (~m), (~x)) &&\n    linear((~u), (~x)) &&\n    !eq((~u), (~x)) ?\n1⨸Symbolics.coeff((~u), (~x)^ 1)*int_and_subst(((~a) + (~b)*(~x))^(~m),  (~x), (~x), (~u), \"1_1_1_1_5\") : nothing)\n\nand this works:\n\njulia> integrate((1+a*(1+x))^2,x)\n((1 + a*(1 + x))^3) / (3a)\n\nbut doing this (now integration variable is a) doesnt:\n\njulia> integrate((1+x*(1+a))^2,a)\nNo rule found for ∫((1 + (1 + a)*x)^2, a)\n\nThis is because in this new expression the matches are\n\n~u matches x\n~!b matches 1+a\n\nso the rule returns but then the condition linear(x, a) fails","category":"section"},{"location":"methods/rulebased/#another-example","page":"Rule based method","title":"another example","text":"1/(sqrt(1+200x)*sqrt(2-x)) should integrate with the rule\n\n(\"1_1_1_2_23\",\n@rule ∫(1/(sqrt((~!a) + (~!b)*(~x))*sqrt((~!c) + (~!d)*(~x))),(~x)) =>\n    !contains_var((~a), (~b), (~c), (~d), (~x)) &&\n    gt((~b)*(~c) - (~a)*(~d), 0) &&\n    gt((~b), 0) ?\n2⨸sqrt((~b))* int_and_subst(1⨸sqrt((~b)*(~c) - (~a)*(~d) + (~d)*(~x)^2), (~x), (~x), sqrt((~a) + (~b)*(~x)), \"1_1_1_2_23\") : nothing)\n\nbut the second condition is true only for 200*2 - 1*(-1) = 401 > 0 and not for (-1)*1 - 2*200 = -401 not > 0","category":"section"},{"location":"methods/rulebased/#neim-problem","page":"Rule based method","title":"neim problem","text":"neim stands for negative exponents in multiplications\n\nIf I define a rule with this pattern @rule ((~!a) + (~!b)*(~x))^(~m)*((~!c) + (~!d)*(~x))^(~n)~)) it can correctly match something like (1+2x)^2 * (3+4x)^3. But when one of the two exponents is negative, let's say -3, this expression is represented in julia as (1+2x)^2 / (3+4x)^3). Or when both are negative, the expression is represented as 1 / ( (1+2x)^2 * (3+4x)^3 ). The matcher inside the rule instead, searches for a * as first operation, and thus doesn't recognize the expression. For this reason (1 + 3x)^2 / (1 + 2x)), (x^6) / (1 + 2(x^6)) and many other expressions dont get integrated. For more info you can read the issue. In the new version of rules tho some cases of the problem are solved with some tricks","category":"section"},{"location":"methods/rulebased/#Minor","page":"Rule based method","title":"Minor","text":"in runtests, exp(x) is not recognized as ℯ^x. This is because integration produces a ℯ^x that doesnt get automatically translated into exp(x) like happens in the REPL\nroots of numbers are not treated simbolically but immediately calculated. So instead of the beautiful integrate(1/(sqrt(1+2x)*sqrt(3+4x))) = asinh(sqrt(2)*sqrt(1+2x))/sqrt(2), i have = 0.7071067811865475asinh(1.414213562373095sqrt(1 + 2x)). Or instead of integrate(2^x) = 2^x / log(2), i have integrate(2^x) = 1.4426950408889634*2^x. Or instead of integrate((2/sqrt(π))*exp(-x^2)) = SpecialFunctions.erf(x) I have  integrate((2/sqrt(π))*exp(-x^2)) = 0.9999999999999999SpecialFunctions.erf(x)\nthe variable USEGAMMA is used to choose if gamma function is used in the results or not. But right now is not configurable by the user, and if changed doesnt change the behaviour of th eintegration but a reloadrules() is needed, i dont know why.\nwhy here the coefficient is Inf ?\n\njulia> integrate((3 + 4*x)^2.2/(1 + 2*x))\nNo rule found for ∫(((3 + 4x)^2.2) / (1 + 2x), x)\nintegration of ∫(((3 + 4x)^2.2) / (1 + 2x), x) failed, trying with this mathematically equivalent integrand:\n∫(((1 + 2x)^-1)*((3 + 4x)^2.2), x)\n┌-------Applied rule 1_1_1_2_37 on ∫(((1 + 2x)^-1)*((3 + 4x)^2.2), x)\n| ∫((a + b * x) ^ (m::!ext_isinteger) * (c + d * x) ^ (n::ext_isinteger), x) => if \n|       !(contains_var(a, b, c, d, m, x)) &&\n|       !(eq(b * c - a * d, 0))\n| (((b * c - a * d) ^ n * (a + b * x) ^ (m + 1)) / (b ^ (n + 1) * (m + 1))) * hypergeometric2f1(-n, m + 1, m + 2, (-d * (a + b * x)) / (b * c - a * d))\n└-------with result: Inf*SymbolicIntegration.hypergeometric2f1(-2.2, 0, 1, (-2//1)*(1 + 2x))\nInf*SymbolicIntegration.hypergeometric2f1(-2.2, 0, 1, (-2//1)*(1 + 2x))\n","category":"section"},{"location":"methods/rulebased/#Testing","page":"Rule based method","title":"Testing","text":"There is a test suite of 27585 solved integrals taken from the RUBI package, in the folders test/test_files/0 Independent test suites (1796 tests) and test/test_files/1 Algebraic functions (25798 tests). They can be used to test the package running\n\njulia --project=. test/runtests.jl\n\nor in a Repl:\n\n(@v1.11) pkg> activate .\n  Activating project at `~/.julia/dev/SymbolicIntegration.jl`\n\njulia> using Symbolics, SymbolicIntegration\n\njulia> include(\"test/runtests.jl\")\n\n\nThis will create a .out file with the test results. You can select which testests to test in the script test/runtests.jl.\n\nTo count how many tests are there you can use this command:\n\nfind \"test/test_files/0 Independent test suites\" -type f -exec grep -c '^(' {} \\; | awk '{sum += $1} END {print \"Total matches:\", sum}' ","category":"section"},{"location":"methods/rulebased/#Contributing","page":"Rule based method","title":"Contributing","text":"see this docs page","category":"section"},{"location":"#SymbolicIntegration.jl","page":"Home","title":"SymbolicIntegration.jl","text":"SymbolicIntegration.jl lets you solve indefinite integrals (finds primitives) in Julia Symbolics.jl. It does so using two symbolic integration algorithms: Risch algorithm and Rule based algorithm.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"julia> using Pkg; Pkg.add(\"SymbolicIntegration\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using SymbolicIntegration, Symbolics\n\n@variables x a\n\n# Basic polynomial integration\nintegrate(x^2, x)  # Returns (1//3)*(x^3)\n\n# Rational function integration\nintegrate(1/(x^2 + 1), x)  # Returns atan(x)\nf = (x^3 + x^2 + x + 2)/(x^4 + 3*x^2 + 2)\nintegrate(f, x)  # Returns (1//2)*log(2 + x^2) + atan(x)\n\n# Transcendental functions\nintegrate(exp(x), x)    # Returns exp(x)\nintegrate(log(x), x)    # Returns -x + x*log(x)\n\n# Method selection and configuration\nintegrate(f, x, RischMethod())  # Explicit method choice\nintegrate(f, x, RischMethod(use_algebraic_closure=true))  # With options","category":"section"},{"location":"#Integration-Methods","page":"Home","title":"Integration Methods","text":"SymbolicIntegration.jl provides two integration algorithms: Risch method and Rule based method.\n\nDefault Behavior: When no method is explicitly specified, integrate() will first attempt the Rule based method. If it fails, it will then try with the Risch method.\n\nHere is a quick table to see what each method can integrate:\n\nfeature Risch Rule based\nrational functions ✅ ✅\nnon integers powers ❌ ✅\nexponential functions ✅ ✅\nlogarithms ✅ ✅\ntrigonometric functions ? sometimes\nhyperbolic functions ✅ sometimes\nNonelementary integrals ❌ most of them\nSpecial functions ❌ ❌\nmultiple symbols ❌ ✅","category":"section"},{"location":"#RuleBased","page":"Home","title":"RuleBased","text":"This method uses a large number of integration rules that specify how to integrate various mathematical expressions.\n\nintegrate(x^2 + 1, x, RuleBasedMethod(verbose=true, use_gamma=false))\n\nverbose specifies whether to print or not the integration rules applied (very helpful)\nuse_gamma specifies whether to use rules with the gamma function in the result, or not (default false)\n\n→ See detailed Rule based documentation","category":"section"},{"location":"#RischMethod","page":"Home","title":"RischMethod","text":"This method is based on the algorithms from the book:\n\nManuel Bronstein, Symbolic Integration I: Transcentental Functions, 2nd ed, Springer 2005,\n\nfor which a pretty complete set of reference implementations is provided. As in the book, integrands involving algebraic functions like sqrt and non-integer powers are not treated.\n\nintegrate(x^2 + 1, x, RischMethod(use_algebraic_closure=false, catch_errors=true))\n\nuse_algebraic_closure does what?\ncatch_errors does what?\n\n→ See detailed Risch documentation","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"We welcome contributions! Please see the contributing page and the Symbolics.jl contributing guidelines.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use SymbolicIntegration.jl in your research, please cite:\n\n@software{SymbolicIntegration.jl,\n  author = {Mattia Micheletta Merlin, Harald Hofstätter and Chris Rackauckas},,\n  title = {SymbolicIntegration.jl: Symbolic Integration for Julia},\n  url = {https://github.com/JuliaSymbolics/SymbolicIntegration.jl},\n  year = {2023-2025}\n}","category":"section"},{"location":"methods/risch_transcendental_functions/#Transcendental-Function-Integration-with-Risch-algorithm","page":"Transcendental Function Integration with Risch algorithm","title":"Transcendental Function Integration with Risch algorithm","text":"SymbolicIntegration.jl implements the Risch algorithm for integrating elementary transcendental functions.","category":"section"},{"location":"methods/risch_transcendental_functions/#Supported-Functions","page":"Transcendental Function Integration with Risch algorithm","title":"Supported Functions","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/#Exponential-Functions","page":"Transcendental Function Integration with Risch algorithm","title":"Exponential Functions","text":"using SymbolicIntegration, Symbolics\n@variables x\n\nintegrate(exp(x), x)        # exp(x)\nintegrate(exp(2*x), x)      # (1//2)*exp(2*x)\nintegrate(x*exp(x), x)      # -exp(x) + x*exp(x)","category":"section"},{"location":"methods/risch_transcendental_functions/#Logarithmic-Functions","page":"Transcendental Function Integration with Risch algorithm","title":"Logarithmic Functions","text":"integrate(log(x), x)        # -x + x*log(x)\nintegrate(1/(x*log(x)), x)  # log(log(x))\nintegrate(log(x)^2, x)      # x*log(x)^2 - 2*x*log(x) + 2*x","category":"section"},{"location":"methods/risch_transcendental_functions/#Trigonometric-Functions","page":"Transcendental Function Integration with Risch algorithm","title":"Trigonometric Functions","text":"Basic trigonometric functions are transformed to exponential form:\n\nintegrate(sin(x), x)   # Transformed via half-angle formulas\nintegrate(cos(x), x)   # Transformed via half-angle formulas  \nintegrate(tan(x), x)   # Uses differential field extension","category":"section"},{"location":"methods/risch_transcendental_functions/#Hyperbolic-Functions","page":"Transcendental Function Integration with Risch algorithm","title":"Hyperbolic Functions","text":"Hyperbolic functions are transformed to exponential form:\n\nintegrate(sinh(x), x)  # Equivalent to (exp(x) - exp(-x))/2\nintegrate(cosh(x), x)  # Equivalent to (exp(x) + exp(-x))/2\nintegrate(tanh(x), x)  # Transformed to exponential form","category":"section"},{"location":"methods/risch_transcendental_functions/#Algorithm:-The-Risch-Method","page":"Transcendental Function Integration with Risch algorithm","title":"Algorithm: The Risch Method","text":"The Risch algorithm builds a tower of differential fields to handle transcendental extensions systematically.","category":"section"},{"location":"methods/risch_transcendental_functions/#Differential-Field-Tower","page":"Transcendental Function Integration with Risch algorithm","title":"Differential Field Tower","text":"For an integrand like exp(x^2) * log(x), the algorithm constructs:\n\nBase field: ℚ(x) with derivation d/dx\nFirst extension: ℚ(x, log(x)) with D(log(x)) = 1/x\nSecond extension: ℚ(x, log(x), exp(x^2)) with D(exp(x^2)) = 2*x*exp(x^2)","category":"section"},{"location":"methods/risch_transcendental_functions/#Integration-Steps","page":"Transcendental Function Integration with Risch algorithm","title":"Integration Steps","text":"Field Tower Construction: Build the appropriate differential field tower\nCanonical Form: Transform the integrand to canonical form in the tower\nResidue Computation: Apply the Risch algorithm recursively\nResult Assembly: Convert back to symbolic form","category":"section"},{"location":"methods/risch_transcendental_functions/#Implementation-Details","page":"Transcendental Function Integration with Risch algorithm","title":"Implementation Details","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/#Function-Transformations","page":"Transcendental Function Integration with Risch algorithm","title":"Function Transformations","text":"The algorithm transforms complex functions to simpler forms:\n\nTrigonometric functions → Half-angle formulas with tan(x/2)\nHyperbolic functions → Exponential expressions\nInverse functions → Differential field extensions","category":"section"},{"location":"methods/risch_transcendental_functions/#Example:-sin(x)-Integration","page":"Transcendental Function Integration with Risch algorithm","title":"Example: sin(x) Integration","text":"# sin(x) is transformed to:\n# 2*tan(x/2) / (1 + tan(x/2)^2)\n# Then integrated using the Risch algorithm","category":"section"},{"location":"methods/risch_transcendental_functions/#Advanced-Usage","page":"Transcendental Function Integration with Risch algorithm","title":"Advanced Usage","text":"","category":"section"},{"location":"methods/risch_transcendental_functions/#Direct-Algorithm-Access","page":"Transcendental Function Integration with Risch algorithm","title":"Direct Algorithm Access","text":"You can access the lower-level algorithms directly:\n\n# Use the Risch algorithm directly\nusing SymbolicIntegration\n# ... (advanced example would go here)","category":"section"},{"location":"methods/risch_transcendental_functions/#Custom-Derivations","page":"Transcendental Function Integration with Risch algorithm","title":"Custom Derivations","text":"# Create custom differential field extensions\n# ... (advanced example would go here)  ","category":"section"},{"location":"methods/risch_transcendental_functions/#Limitations","page":"Transcendental Function Integration with Risch algorithm","title":"Limitations","text":"No algebraic functions (√x, x^(1/3), etc.)\nSome complex trigonometric cases may not be handled\nNon-elementary integrals return unevaluated forms","category":"section"}]
}
