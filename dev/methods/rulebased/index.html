<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · SymbolicIntegration.jl</title><meta name="title" content="Usage · SymbolicIntegration.jl"/><meta property="og:title" content="Usage · SymbolicIntegration.jl"/><meta property="twitter:title" content="Usage · SymbolicIntegration.jl"/><meta name="description" content="Documentation for SymbolicIntegration.jl."/><meta property="og:description" content="Documentation for SymbolicIntegration.jl."/><meta property="twitter:description" content="Documentation for SymbolicIntegration.jl."/><meta property="og:url" content="https://symbolicintegration.juliasymbolics.org/stable/methods/rulebased/"/><meta property="twitter:url" content="https://symbolicintegration.juliasymbolics.org/stable/methods/rulebased/"/><link rel="canonical" href="https://symbolicintegration.juliasymbolics.org/stable/methods/rulebased/"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NLF2W4VR1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-6NLF2W4VR1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymbolicIntegration.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../manual/contributing/">Contributing</a></li></ul></li><li><span class="tocitem">Integration Methods</span><ul><li><a class="tocitem" href="../overview/">Integration Methods Overview</a></li><li><a class="tocitem" href="../risch/">Risch Method</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Configuration-options"><span>Configuration options</span></a></li><li class="toplevel"><a class="tocitem" href="#How-it-works-internally"><span>How it works internally</span></a></li><li class="toplevel"><a class="tocitem" href="#Problems"><span>Problems</span></a></li><li><a class="tocitem" href="#Serious"><span>Serious</span></a></li><li><a class="tocitem" href="#Mild"><span>Mild</span></a></li><li><a class="tocitem" href="#Minor"><span>Minor</span></a></li><li class="toplevel"><a class="tocitem" href="#Testing"><span>Testing</span></a></li><li class="toplevel"><a class="tocitem" href="#Contributing"><span>Contributing</span></a></li></ul></li><li><a class="tocitem" href="../risch_rational_functions/">Rational Function Integration</a></li><li><a class="tocitem" href="../risch_transcendental_functions/">Transcendental Function Integration</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Integration Methods</a></li><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicIntegration.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicIntegration.jl/blob/main/docs/src/methods/rulebased.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p><a href="https://github.com/Bumblebee00/SymbolicIntegration.jl"><img src="https://img.shields.io/badge/dynamic/json?url=https://raw.githubusercontent.com/Bumblebee00/SymbolicIntegration.jl/main/.github/badges/rules-count.json&amp;query=\$.message&amp;label=Total%20rules&amp;color=blue" alt="Rules"/></a></p><ul><li><a href="#usage">Usage</a><ul><li><a href="#configuration-options">Configuration options</a></li></ul></li><li><a href="#how-it-works-internally">How it works internally</a></li><li><a href="#problems">Problems</a><ul><li><a href="#serious">Serious</a></li><li><a href="#mild">Mild</a></li><li><a href="#minor">Minor</a></li></ul></li></ul><p>This method uses a large number of integration rules that specify how to integrate various mathematical expressions. The rules were originally taken from the Mathematica package <a href="https://rulebasedintegration.org/">RUBI</a> but later translated into julia.</p><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><pre><code class="nohighlight hljs">julia&gt; integrate(sqrt(4 - 12*x + 9*x^2)+sqrt(1+x), x, RuleBasedMethod())
┌-------Applied rule 0_1_0 on ∫(sqrt(1 + x) + sqrt(4 - 12x + 9(x^2)), x)
| ∫( a + b + ..., x) =&gt; ∫(a,x) + ∫(b,x) + ...
└-------with result: ∫(sqrt(4 - 12x + 9(x^2)), x) + ∫(sqrt(1 + x), x)
┌-------Applied rule 1_1_1_1_4 on ∫(sqrt(1 + x), x)
| ∫((a + b * x) ^ m, x) =&gt; if 
|       !(contains_var(a, b, m, x)) &amp;&amp;
|       m !== -1
| (a + b * x) ^ (m + 1) / (b * (m + 1))
└-------with result: (2//3)*((1 + x)^(3//2))
┌-------Applied rule 1_2_1_1_3 on ∫(sqrt(4 - 12x + 9(x^2)), x)
| ∫((a + b * x + c * x ^ 2) ^ p, x) =&gt; if 
|       !(contains_var(a, b, c, p, x)) &amp;&amp;
|       (
|             b ^ 2 - 4 * a * c == 0 &amp;&amp;
|             p !== -1 / 2
|       )
| ((b + 2 * c * x) * (a + b * x + c * x ^ 2) ^ p) / (2 * c * (2 * p + 1))
└-------with result: (1//36)*(-12 + 18x)*((4 - 12x + 9(x^2))^(1//2))
(2//3)*((1 + x)^(3//2)) + (1//36)*(-12 + 18x)*sqrt(4 - 12x + 9(x^2))</code></pre><h2 id="Configuration-options"><a class="docs-heading-anchor" href="#Configuration-options">Configuration options</a><a id="Configuration-options-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration-options" title="Permalink"></a></h2><ul><li><code>verbose</code> specifies whether to print or not the integration rules applied (default true)</li><li><code>use_gamma</code> specifies whether to use rules with the gamma function in the result, or not (default false)</li></ul><h1 id="How-it-works-internally"><a class="docs-heading-anchor" href="#How-it-works-internally">How it works internally</a><a id="How-it-works-internally-1"></a><a class="docs-heading-anchor-permalink" href="#How-it-works-internally" title="Permalink"></a></h1><p>The rules are defined using the SymbolicUtils <a href="https://symbolicutils.juliasymbolics.org/rewrite/#rule-based_rewriting">rule macro</a> and are of this form:</p><pre><code class="language-julia hljs"># rule 1_1_1_1_2
@rule ∫((~x)^(~!m),(~x)) =&gt;
    !contains_var((~m), (~x)) &amp;&amp;
    !eq((~m), -1) ?
(~x)^((~m) + 1)⨸((~m) + 1) : nothing</code></pre><p>The rule left hand side pattern is the symbolic function <code>∫(var1, var2)</code> where first variable is the integrand and second is the integration variable. After the =&gt; there are some conditions to determine if the rules are applicable, and after the ? there is the transformation. Note that this may still contain a integral, so a walk in pre order of the tree representing the symbolic expression is done, applying rules to each node containing the integral.</p><p>The infix operator <code>⨸</code> is used to represent a custom division function, if called on integers returns a rational and if called on floats returns a float. This is done because // operator does not support floats. This specific character was chosen because it resembles the division symbol and because it has the same precedence as /.</p><h1 id="Problems"><a class="docs-heading-anchor" href="#Problems">Problems</a><a id="Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Problems" title="Permalink"></a></h1><p>Here are the problems holding back the most number of expressions to be integrated</p><h2 id="Serious"><a class="docs-heading-anchor" href="#Serious">Serious</a><a id="Serious-1"></a><a class="docs-heading-anchor-permalink" href="#Serious" title="Permalink"></a></h2><p>Serious problems are problems that strongly impact the correct functioning of the rule based symbolic integrator and are difficult to fix. Here are the ones i encountered so far:</p><ul><li><strong>general rules for trigonometric functions</strong>: when integrating some expressions with trigonometric functions in Mathematica I see that strange rules are applied. Instead of the rule number &quot;General&quot; is showed, and they are strange because involve a level of pattern matching that is out of this world. For example integrating <code>sin(x^2)</code> the applied rule is <code>F(tan(a + bx)</code> where F gets automatically matched to <code>exp(x^2/(1 + x^2)</code>. I mean is correct but how on earth could pattern matching know that...</li></ul><h3 id="neim-problem"><a class="docs-heading-anchor" href="#neim-problem">neim problem</a><a id="neim-problem-1"></a><a class="docs-heading-anchor-permalink" href="#neim-problem" title="Permalink"></a></h3><p>neim stands for negative exponents in multiplications</p><p>If I define a rule with this pattern <code>@rule ((~!a) + (~!b)*(~x))^(~m)*((~!c) + (~!d)*(~x))^(~n)~))</code> it can correctly match something like <code>(1+2x)^2 * (3+4x)^3</code>. But when one of the two exponents is negative, let&#39;s say -3, this expression is represented in julia as <code>(1+2x)^2 / (3+4x)^3)</code>. Or when both are negative, the expression is represented as <code>1 / ( (1+2x)^2 * (3+4x)^3 )</code>. The matcher inside the rule instead, searches for a * as first operation, and thus doesn&#39;t recognize the expression. For this reason <code>(1 + 3x)^2 / (1 + 2x))</code>, <code>(x^6) / (1 + 2(x^6))</code> and many other expressions dont get integrated. For more info you can read <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/issues/777">the issue</a> or see this <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/pull/778">WIP pr</a> in which i try to implement a solution.</p><p>A workaround I implemented is this:</p><pre><code class="nohighlight hljs">julia&gt; ins(expr) = SymbolicUtils.Term{Number}(^,[expr,-1])
ins (generic function with 1 method)

julia&gt; r = @rule (~n)/*(~d) =&gt; ~n*ins(~d)
~n / (*)(~(~d)) =&gt; ~n * prod([ins(el) for el = ~(~d)])

julia&gt; r(a*b/(c*x))
a*b*(c^-1)*(x^-1)</code></pre><p>creating a power with negative exponent, with <code>Term</code> and not with <code>^</code>, doesnt autosimplify it to a division with positive exponent. So the rule can be applied. But is not good enough. here is a list of expressions not integrating due to this problem</p><ul><li>log(x) / (x*sqrt(1 + log(x))) rule 3<em>1</em>5_36 </li><li>1 / (x*sqrt(1 - (x^2))</li><li>log(1 - t) / (1 - t)</li><li>(1 + x^2) / x</li></ul><h2 id="Mild"><a class="docs-heading-anchor" href="#Mild">Mild</a><a id="Mild-1"></a><a class="docs-heading-anchor-permalink" href="#Mild" title="Permalink"></a></h2><p>Mild problems are problems that impact the correct functioning of the rule based symbolic integrator and are medium difficulty to fix. Here are the ones I encountered so far:</p><ul><li><p><strong>ExpandIntegrand function</strong>: In the Mathematica package is defined the <code>ExpandIntegrand</code> function that expands a lot of mathematical expression (is defined in more than 360 rules of code) in strange ways. Some cases are been adderssed for now in the function <code>ext_expand</code>, but not all</p></li><li><p><strong>Maybe erorred tests</strong>: when testing, one checks that the integral is correct with <code>isequal(simplify(computed_result  - real_result;expand=true), 0)</code> but this doesnt always work. For example:</p></li></ul><pre><code class="nohighlight hljs">[fail]∫( (x^2)*sqrt(1 + x) )dx = 
  (2//3)*((1 + x)^(3//2)) - (4//5)*((1 + x)^(5//2)) + (2//7)*((1 + x)^(7//2)) but got:
  -(4//7)*(-(2//3)*((1 + x)^(3//2)) + (2//5)*((1 + x)^(5//2))) + (2//7)*((1 + x)^(3//2))*(x^2)
[fail]∫( (2^sqrt(x)) / sqrt(x) )dx = 1.4426950408889634(2^(1 + sqrt(x))) but got:
      2.8853900817779268(2^(x^(1//2))) (0.2489s)</code></pre><p>even tough the two are mathematically equivalent</p><ul><li><strong>strange behaviour with - sign</strong>:</li></ul><pre><code class="nohighlight hljs">julia&gt; r = @rule (~a) + (~!b)*x =&gt; ~
~a + ~(!b) * x =&gt; (~)

julia&gt; r(1+c*x)
Base.ImmutableDict{Symbol, Any} with 4 entries:
  :MATCH =&gt; 1 + c*x
  :b     =&gt; c
  :a     =&gt; 1
  :____  =&gt; nothing

julia&gt; r(1-c*x)
</code></pre><p>because -c*x is represented as a three factor moltiplication between -1, c and x</p><ul><li>integrals with complex numbers dont work very well</li></ul><h3 id="mild-problem:-oooomm"><a class="docs-heading-anchor" href="#mild-problem:-oooomm">mild problem: oooomm</a><a id="mild-problem:-oooomm-1"></a><a class="docs-heading-anchor-permalink" href="#mild-problem:-oooomm" title="Permalink"></a></h3><p>oooomm stands for only one out of multiple matches.</p><p>one rule can have more than one match. for example <code>@rule ((~!a) + (~!b)*(~x))^(~m)*((~!c) + (~!d)*(~x))^(~n)~))</code> can match <code>(1+2x)^2 * (3+4x)^3</code> with both m=2, n=3, ... or m=3, n=2, ... . Only one match of the possible ones is returned. but a usual rule form rubi is @rule pattern =&gt; if (conditions...) result else nothing. So first the pattern is found, but then if it doesnt match the conditions the rule returns nothing. But maybe one of the other possible matches matched the condition and the rule would have been applied. For more detail read <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/issues/776">the issue</a> and see this <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/pull/772">WIP pr</a> in which i try to implement a solution.</p><h4 id="Example-in-intgeration"><a class="docs-heading-anchor" href="#Example-in-intgeration">Example in intgeration</a><a id="Example-in-intgeration-1"></a><a class="docs-heading-anchor-permalink" href="#Example-in-intgeration" title="Permalink"></a></h4><p>For example the problem presents itself in the following case. The rule is</p><pre><code class="language-julia hljs">(&quot;1_1_1_1_5&quot;,
@rule ∫(((~!a) + (~!b)*(~u))^(~m),(~x)) =&gt;
    !contains_var((~a), (~b), (~m), (~x)) &amp;&amp;
    linear((~u), (~x)) &amp;&amp;
    !eq((~u), (~x)) ?
1⨸Symbolics.coeff((~u), (~x)^ 1)*int_and_subst(((~a) + (~b)*(~x))^(~m),  (~x), (~x), (~u), &quot;1_1_1_1_5&quot;) : nothing)</code></pre><p>and this works:</p><pre><code class="nohighlight hljs">julia&gt; integrate((1+a*(1+x))^2,x)
((1 + a*(1 + x))^3) / (3a)</code></pre><p>but doing this (now integration variable is a) doesnt:</p><pre><code class="nohighlight hljs">julia&gt; integrate((1+x*(1+a))^2,a)
No rule found for ∫((1 + (1 + a)*x)^2, a)</code></pre><p>This is because in this new expression the matches are</p><ul><li>~u matches x</li><li>~!b matches 1+a</li></ul><p>so the rule returns but then the condition <code>linear(x, a)</code> fails</p><h4 id="another-example"><a class="docs-heading-anchor" href="#another-example">another example</a><a id="another-example-1"></a><a class="docs-heading-anchor-permalink" href="#another-example" title="Permalink"></a></h4><p><code>1/(sqrt(1+200x)*sqrt(2-x))</code> should integrate with the rule</p><pre><code class="nohighlight hljs">(&quot;1_1_1_2_23&quot;,
@rule ∫(1/(sqrt((~!a) + (~!b)*(~x))*sqrt((~!c) + (~!d)*(~x))),(~x)) =&gt;
    !contains_var((~a), (~b), (~c), (~d), (~x)) &amp;&amp;
    gt((~b)*(~c) - (~a)*(~d), 0) &amp;&amp;
    gt((~b), 0) ?
2⨸sqrt((~b))* int_and_subst(1⨸sqrt((~b)*(~c) - (~a)*(~d) + (~d)*(~x)^2), (~x), (~x), sqrt((~a) + (~b)*(~x)), &quot;1_1_1_2_23&quot;) : nothing)</code></pre><p>but the second condition is true only for <code>200*2 - 1*(-1) = 401 &gt; 0</code> and not for <code>(-1)*1 - 2*200 = -401 not &gt; 0</code></p><h2 id="Minor"><a class="docs-heading-anchor" href="#Minor">Minor</a><a id="Minor-1"></a><a class="docs-heading-anchor-permalink" href="#Minor" title="Permalink"></a></h2><ul><li>in runtests, exp(x) is not recognized as ℯ^x. This is because integration produces a ℯ^x that doesnt get automatically translated into exp(x) like happens in the REPL</li><li>roots of numbers are not treated simbolically but immediately calculated. So instead of the beautiful <code>integrate(1/(sqrt(1+2x)*sqrt(3+4x))) = asinh(sqrt(2)*sqrt(1+2x))/sqrt(2)</code>, i have <code>= 0.7071067811865475asinh(1.414213562373095sqrt(1 + 2x))</code>. Or instead of <code>integrate(2^x) = 2^x / log(2)</code>, i have <code>integrate(2^x) = 1.4426950408889634*2^x</code>. Or instead of <code>integrate((2/sqrt(π))*exp(-x^2)) = SpecialFunctions.erf(x)</code> I have  <code>integrate((2/sqrt(π))*exp(-x^2)) = 0.9999999999999999SpecialFunctions.erf(x)</code></li><li>the variable USE<em>GAMMA is used to choose if gamma function is used in the results or not. But right now is not configurable by the user, and if changed doesnt change the behaviour of th eintegration but a reload</em>rules() is needed, i dont know why.</li><li>why here the coefficient is Inf ?</li></ul><pre><code class="nohighlight hljs">julia&gt; integrate((3 + 4*x)^2.2/(1 + 2*x))
No rule found for ∫(((3 + 4x)^2.2) / (1 + 2x), x)
integration of ∫(((3 + 4x)^2.2) / (1 + 2x), x) failed, trying with this mathematically equivalent integrand:
∫(((1 + 2x)^-1)*((3 + 4x)^2.2), x)
┌-------Applied rule 1_1_1_2_37 on ∫(((1 + 2x)^-1)*((3 + 4x)^2.2), x)
| ∫((a + b * x) ^ (m::!ext_isinteger) * (c + d * x) ^ (n::ext_isinteger), x) =&gt; if 
|       !(contains_var(a, b, c, d, m, x)) &amp;&amp;
|       !(eq(b * c - a * d, 0))
| (((b * c - a * d) ^ n * (a + b * x) ^ (m + 1)) / (b ^ (n + 1) * (m + 1))) * hypergeometric2f1(-n, m + 1, m + 2, (-d * (a + b * x)) / (b * c - a * d))
└-------with result: Inf*SymbolicIntegration.hypergeometric2f1(-2.2, 0, 1, (-2//1)*(1 + 2x))
Inf*SymbolicIntegration.hypergeometric2f1(-2.2, 0, 1, (-2//1)*(1 + 2x))
</code></pre><h1 id="Testing"><a class="docs-heading-anchor" href="#Testing">Testing</a><a id="Testing-1"></a><a class="docs-heading-anchor-permalink" href="#Testing" title="Permalink"></a></h1><p>There is a test suite of 27585 solved integrals taken from the RUBI package, in the folders <code>test/test_files/0 Independent test suites</code> (1796 tests) and <code>test/test_files/1 Algebraic functions</code> (25798 tests). They can be used to test the package running</p><pre><code class="nohighlight hljs">julia --project=. test/runtests.jl</code></pre><p>or in a Repl:</p><pre><code class="nohighlight hljs">(@v1.11) pkg&gt; activate .
  Activating project at `~/.julia/dev/SymbolicIntegration.jl`

julia&gt; using Symbolics, SymbolicIntegration

julia&gt; include(&quot;test/runtests.jl&quot;)
</code></pre><p>This will create a .out file with the test results. You can select which testests to test in the script <code>test/runtests.jl</code>.</p><p>To count how many tests are there you can use this command:</p><pre><code class="language-bash hljs">find &quot;test/test_files/0 Independent test suites&quot; -type f -exec grep -c &#39;^(&#39; {} \; | awk &#39;{sum += $1} END {print &quot;Total matches:&quot;, sum}&#39; </code></pre><h1 id="Contributing"><a class="docs-heading-anchor" href="#Contributing">Contributing</a><a id="Contributing-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing" title="Permalink"></a></h1><p>see this <a href>docs page</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../risch/">« Risch Method</a><a class="docs-footer-nextpage" href="../risch_rational_functions/">Rational Function Integration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 7 November 2025 22:14">Friday 7 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
