<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Contributing · SymbolicIntegration.jl</title><meta name="title" content="Contributing · SymbolicIntegration.jl"/><meta property="og:title" content="Contributing · SymbolicIntegration.jl"/><meta property="twitter:title" content="Contributing · SymbolicIntegration.jl"/><meta name="description" content="Documentation for SymbolicIntegration.jl."/><meta property="og:description" content="Documentation for SymbolicIntegration.jl."/><meta property="twitter:description" content="Documentation for SymbolicIntegration.jl."/><meta property="og:url" content="https://symbolicintegration.juliasymbolics.org/stable/manual/contributing/"/><meta property="twitter:url" content="https://symbolicintegration.juliasymbolics.org/stable/manual/contributing/"/><link rel="canonical" href="https://symbolicintegration.juliasymbolics.org/stable/manual/contributing/"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NLF2W4VR1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-6NLF2W4VR1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymbolicIntegration.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Contributing</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Contributing-to-translating-new-rules-for-RuleBasedMethod"><span>Contributing to translating new rules for RuleBasedMethod</span></a></li><li><a class="tocitem" href="#Common-problems-when-translating-rules"><span>Common problems when translating rules</span></a></li><li><a class="tocitem" href="#Description-of-the-script-src/translator_of_rules.jl"><span>Description of the script <code>src/translator_of_rules.jl</code></span></a></li><li><a class="tocitem" href="#Adding-Testsuites"><span>Adding Testsuites</span></a></li></ul></li></ul></li><li><span class="tocitem">Integration Methods</span><ul><li><a class="tocitem" href="../../methods/overview/">Integration Methods Overview</a></li><li><a class="tocitem" href="../../methods/risch/">Risch Method</a></li><li><a class="tocitem" href="../../methods/rulebased/">Rule based method</a></li><li><a class="tocitem" href="../../methods/risch_rational_functions/">Rational Function Integration with Risch algorithm</a></li><li><a class="tocitem" href="../../methods/risch_transcendental_functions/">Transcendental Function Integration with Risch algorithm</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Contributing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Contributing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicIntegration.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicIntegration.jl/blob/main/docs/src/manual/contributing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Contributing"><a class="docs-heading-anchor" href="#Contributing">Contributing</a><a id="Contributing-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing" title="Permalink"></a></h1><p>We welcome contributions!</p><p>Below there are detailed info on how to contribute to the translation of new rules from the Mathematica <a href="https://rulebasedintegration.org/">RUBI</a> package, or translation of solved integrals to use as tests, from the same package.</p><ul><li><a href="#contributing-to-rulebasedmethod">Contributing to RuleBasedMethod</a><ul><li><a href="#common-problems-when-translating-rules">Common problems when translating rules</a><ul><li><a href="#function-not-translated">function not translated</a></li><li><a href="#sum-function-translation">Sum function translation</a></li><li><a href="#module-syntax-translation">Module syntax translation</a></li><li><a href="#-not-present-or-present-as-star">* not present or present as [Star]</a></li></ul></li><li><a href="#description-of-the-script-srctranslator_of_rulesjl">Description of the script <code>src/translator_of_rules.jl</code></a><ul><li><a href="#how-to-use-it">How to use it</a></li><li><a href="#how-it-works-internally-useful-to-know-if-you-have-to-debug-it">How it works internally (useful to know if you have to debug it)</a><ul><li><a href="#with-syntax">With syntax</a></li><li><a href="#replace-and-smart_replace-applications">replace and smart_replace applications</a></li><li><a href="#pretty-indentation">Pretty indentation</a></li><li><a href="#end">end</a></li></ul></li></ul></li><li><a href="#adding-testsuites">Adding Testsuites</a></li></ul></li></ul><h1 id="Contributing-to-translating-new-rules-for-RuleBasedMethod"><a class="docs-heading-anchor" href="#Contributing-to-translating-new-rules-for-RuleBasedMethod">Contributing to translating new rules for RuleBasedMethod</a><a id="Contributing-to-translating-new-rules-for-RuleBasedMethod-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing-to-translating-new-rules-for-RuleBasedMethod" title="Permalink"></a></h1><p>In the github repo of the package there is also some software that serves the sole purpose of helping with the translation of rules from Mathematica syntax, and not for the actual package working. The important ones are:</p><ul><li>translator<em>of</em>rules.jl is a script that with regex and other string manipulations translates from Mathematica syntax to julia syntax (see &quot;houw to use it&quot; section later)</li><li>translator<em>of</em>testset.jl is a script that translates the testsets into julia syntax (much simpler than translator<em>of</em>rules.jl)</li><li><code>reload_rules</code> function in rules_loader.jl. When developing the package using Revise is not enough because rules are defined with a macro. So this function reloads rules from a specific .jl file or from all files if called without arguments.</li></ul><p>my typical workflow is:</p><ul><li>translate a rule file with translator<em>of</em>rules.jl. In the resulting file there could be some problems:</li><li><ul><li>maybe a Mathematica function that i never encountered before and therefore not included in the translation script (and in rules<em>utility</em>functions.jl)</li></ul></li><li><ul><li>maybe a Mathematica syntax that I never encountered before and not included in the translation script</li></ul></li><li><ul><li>others, see <a href="#common-problems-when-translating-rules">Common problems when translating rules</a></li></ul></li><li>If the problem is quite common in other rules: implement in the translation script and translate the rule again, otherwise fix it manually in the .jl file</li></ul><p>The rules not yet translated are mainly those from sections 4 to 8</p><h2 id="Common-problems-when-translating-rules"><a class="docs-heading-anchor" href="#Common-problems-when-translating-rules">Common problems when translating rules</a><a id="Common-problems-when-translating-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Common-problems-when-translating-rules" title="Permalink"></a></h2><h3 id="function-not-translated"><a class="docs-heading-anchor" href="#function-not-translated">function not translated</a><a id="function-not-translated-1"></a><a class="docs-heading-anchor-permalink" href="#function-not-translated" title="Permalink"></a></h3><p>If you encounter a normal function that is not translated by the script, it will stay untranslated, with square brackets, like this:</p><pre><code class="nohighlight hljs">sqrt(Sign[(~b)]*sin((~e) + (~f)*(~x)))⨸sqrt((~d)*sin((~e) + (~f)*(~x)))* ∫(1⨸(sqrt((~a) + (~b)*sin((~e) + (~f)*(~x)))*sqrt(Sign[(~b)]*sin((~e) + (~f)*(~x)))), (~x)) : nothing)</code></pre><p>a trick to find them fast is to search the regex pattern <code>(?&lt;=^[^#]).*\[</code> in all the file. If you find them and they are already presen in julia or you implement them in rules<em>utility</em>functions.jl, you can simply add the to the smart_replace list in the translator and translate the script again.</p><h3 id="Sum-function-translation"><a class="docs-heading-anchor" href="#Sum-function-translation">Sum function translation</a><a id="Sum-function-translation-1"></a><a class="docs-heading-anchor-permalink" href="#Sum-function-translation" title="Permalink"></a></h3><p>the <code>Sum[...]</code> function gets translated with this regex:</p><pre><code class="nohighlight hljs">(r&quot;Sum\[(.*?),\s*\{(.*?),(.*?),(.*?)\}\]&quot;, s&quot;sum([\1 for \2 in (\3):(\4)])&quot;), </code></pre><p>its quite common that the \1 is a &lt;=2 letter variable, and so will get translated from the translator into a slot variable, appending ~.</p><p>For example</p><pre><code class="nohighlight hljs">Sum[Int[1/(1 - Sin[e + f*x]^2/((-1)^(4*k/n)*Rt[-a/b, n/2])), x], {k, 1, n/2}]</code></pre><p>gets translated to </p><pre><code class="nohighlight hljs">sum([∫(1⨸(1 - sin((~e) + (~f)*(~x))^2⨸((-1)^(4*(~k)⨸(~n))*rt(-(~a)⨸(~b), (~n)⨸2))), (~x)) for (~k) in ( 1):( (~n)⨸2)]</code></pre><p>while it should be</p><pre><code class="nohighlight hljs">sum([∫(1⨸(1 - sin((~e) + (~f)*(~x))^2⨸((-1)^(4*k⨸(~n))*rt(-(~a)⨸(~b), (~n)⨸2))), (~x)) for k in ( 1):( (~n)⨸2)]),</code></pre><p>so what I usually do is to change the &quot;index of the summation&quot; variable to a &gt;2 letters name in the Mathematica file, like this</p><pre><code class="nohighlight hljs">Sum[Int[1/(1 - Sin[e + f*x]^2/((-1)^(4*iii/n)*Rt[-a/b, n/2])), x], {iii, 1, n/2}]</code></pre><p>so that will not be translated into slot variable.</p><pre><code class="nohighlight hljs">sum([∫(1⨸(1 - sin((~e) + (~f)*(~x))^2⨸((-1)^(4*iii⨸(~n))*rt(-(~a)⨸(~b), (~n)⨸2))), (~x)) for iii in ( 1):( (~n)⨸2)]),</code></pre><h3 id="Module-syntax-translation"><a class="docs-heading-anchor" href="#Module-syntax-translation">Module syntax translation</a><a id="Module-syntax-translation-1"></a><a class="docs-heading-anchor-permalink" href="#Module-syntax-translation" title="Permalink"></a></h3><p>The <code>Module</code> Syntax is similar to the <code>With</code> syntax, but a bit different and for now is not handled by the script</p><h3 id="*-not-present-or-present-as-[Star]"><a class="docs-heading-anchor" href="#*-not-present-or-present-as-[Star]">* not present or present as [Star]</a><a id="*-not-present-or-present-as-[Star]-1"></a><a class="docs-heading-anchor-permalink" href="#*-not-present-or-present-as-[Star]" title="Permalink"></a></h3><p>in Mathematica if you write <code>a b</code> or <code>a \[Star] b</code> is interpreted as <code>a*b</code>. So sometimes in the rules is written like that. When it happens i usually add the * in the mathematica file,  and then i translate it</p><h2 id="Description-of-the-script-src/translator_of_rules.jl"><a class="docs-heading-anchor" href="#Description-of-the-script-src/translator_of_rules.jl">Description of the script <code>src/translator_of_rules.jl</code></a><a id="Description-of-the-script-src/translator_of_rules.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Description-of-the-script-src/translator_of_rules.jl" title="Permalink"></a></h2><p>This script is used to translate integration rules from Mathematica syntax to julia Syntax.</p><h3 id="How-to-use-it"><a class="docs-heading-anchor" href="#How-to-use-it">How to use it</a><a id="How-to-use-it-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use-it" title="Permalink"></a></h3><p>In the branch <code>rules</code> of the github repo of the package there are all the Mathematica files containing the untranslated rules already in the correct folders in this repo, so that you can use the translator script like this:</p><pre><code class="language-bash hljs">julia src/translator_of_rules.jl &quot;src/rules/4 Trig functions/4.1 Sine/4.1.8 trig^m (a+b cos^p+c sin^q)^n.m&quot;</code></pre><p>this will produce the julia file at the path <code>src/rules/4 Trig functions/4.1 Sine/4.1.8 trig^m (a+b cos^p+c sin^q)^n.jl</code></p><h3 id="How-it-works-internally-(useful-to-know-if-you-have-to-debug-it)"><a class="docs-heading-anchor" href="#How-it-works-internally-(useful-to-know-if-you-have-to-debug-it)">How it works internally (useful to know if you have to debug it)</a><a id="How-it-works-internally-(useful-to-know-if-you-have-to-debug-it)-1"></a><a class="docs-heading-anchor-permalink" href="#How-it-works-internally-(useful-to-know-if-you-have-to-debug-it)" title="Permalink"></a></h3><p>It processes line per line, so the integration rule must be all on only one  line. Let&#39;s say we translate this (fictional) rule:</p><pre><code class="nohighlight hljs">Int[x_^m_./(a_ + b_. + c_.*x_^4), x_Symbol] := With[{q = Rt[a/c, 2], r = Rt[2*q - b/c, 2]}, 1/(2*c*r)*Int[x^(m - 3), x] - 1/(2*c*r) /; OddQ[r]] /; FreeQ[{a, b, c}, x] &amp;&amp; (NeQ[b^2 - 4*a*c, 0] || (GeQ[m, 3] &amp;&amp; LtQ[m, 4])) &amp;&amp; NegQ[b^2 - 4*a*c]</code></pre><h4 id="With-syntax"><a class="docs-heading-anchor" href="#With-syntax">With syntax</a><a id="With-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#With-syntax" title="Permalink"></a></h4><p>for each line it first check if there is the With syntax, a syntax in Mathematica that enables to define variables in a local scope. If yes it can do two things: In the new method translates the block using the let syntax, like this:</p><pre><code class="language-julia hljs">@rule ∫((~x)^(~!m)/((~a) + (~!b) + (~!c)*(~x)^4),(~x)) =&gt;
    !contains_var((~a), (~b), (~c), (~x)) &amp;&amp;
    (
        !eq((~b)^2 - 4*(~a)*(~c), 0) ||
        (
            ge((~m), 3) &amp;&amp;
            lt((~m), 4)
        )
    ) &amp;&amp;
    neg((~b)^2 - 4*(~a)*(~c)) ?
let
    q = rt((~a)⨸(~c), 2)
    r = rt(2*q - (~b)⨸(~c), 2)
    
    ext_isodd(r) ?
    1⨸(2*(~c)*r)*∫((~x)^((~m) - 3), (~x)) - 1⨸(2*(~c)*r) : nothing
end : nothing</code></pre><p>The old method was to finds the defined variables and substitute them with their definition. Also there could be conditions inside the With block (OddQ in the example), that were bought outside.</p><pre><code class="nohighlight hljs">1/(2*c*Rt[2*q - b/c, 2])*Int[x^(m - 3), x] - 1/(2*c*Rt[2*q - b/c, 2])/;  FreeQ[{a, b, c}, x] &amp;&amp; (NeQ[b^2 - 4*a*c, 0] || (GeQ[m, 3] &amp;&amp; LtQ[m, 4])) &amp;&amp; NegQ[b^2 - 4*a*c] &amp;&amp;  OddQ[Rt[2*q - b/c, 2]]</code></pre><h4 id="replace-and-smart_replace-applications"><a class="docs-heading-anchor" href="#replace-and-smart_replace-applications">replace and smart_replace applications</a><a id="replace-and-smart_replace-applications-1"></a><a class="docs-heading-anchor-permalink" href="#replace-and-smart_replace-applications" title="Permalink"></a></h4><p>Then the line is split into integral, result, and conditions:</p><pre><code class="nohighlight hljs">Int[x_^m_./(a_ + b_. + c_.*x_^4), x_Symbol]</code></pre><pre><code class="nohighlight hljs">1/(2*c*Rt[2*q - b/c, 2])*Int[x^(m - 3), x] - 1/(2*c*Rt[2*q - b/c, 2])</code></pre><pre><code class="nohighlight hljs">FreeQ[{a, b, c}, x] &amp;&amp; (NeQ[b^2 - 4*a*c, 0] || (GeQ[m, 3] &amp;&amp; LtQ[m, 4])) &amp;&amp; NegQ[b^2 - 4*a*c] &amp;&amp;  OddQ[Rt[2*q - b/c, 2]]</code></pre><p>Each one of them is translated using the appropriate function, but the three all work the same. They first apply a number of times the smart_replace function, that replaces functions names without messing the nested brackets (like normal regex do)</p><pre><code class="nohighlight hljs">smart_replace(&quot;ArcTan[Rt[b, 2]*x/Rt[a, 2]] + Log[x]&quot;, &quot;ArcTan&quot;, &quot;atan&quot;)
# output
&quot;atan(Rt[b, 2]*x/Rt[a, 2]) + Log[x]&quot;</code></pre><p>Then also the normal replace function is applied a number of times, for more complex patterns. For example, every two letter word, optionally followed by  numbers, that is not a function call (so not followed by open parenthesis), and that is not the &quot;in&quot; word, is prefixed with a tilde <code>~</code>. This is because in Mathematica you can reference the slot variables without any prefix, and in julia you need ~.</p><h4 id="Pretty-indentation"><a class="docs-heading-anchor" href="#Pretty-indentation">Pretty indentation</a><a id="Pretty-indentation-1"></a><a class="docs-heading-anchor-permalink" href="#Pretty-indentation" title="Permalink"></a></h4><p>Then they are all put together following the julia rules syntax @rule integrand =&gt; conditions ? result : nothing</p><pre><code class="nohighlight hljs">@rule ∫((~x)^(~!m)/((~a) + (~!b) + (~!c)*(~x)^4),(~x)) =&gt; !contains_var((~a), (~b), (~c), (~x)) &amp;&amp; (!eq((~b)^2 - 4*(~a)*(~c), 0) || (ge((~m), 3) &amp;&amp; lt((~m), 4))) &amp;&amp; neg((~b)^2 - 4*(~a)*(~c)) &amp;&amp; ext_isodd(rt(2*(~q) - (~b)/(~c), 2)) ? 1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2))*∫((~x)^((~m) - 3), (~x)) - 1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2)) : nothing</code></pre><p>Usually the conditions are a lot of &amp;&amp; and ||, so a pretty indentation is  applied automatically that rewrites the rule like this:</p><pre><code class="nohighlight hljs">@rule ∫((~x)^(~!m)/((~a) + (~!b) + (~!c)*(~x)^4),(~x)) =&gt;
    !contains_var((~a), (~b), (~c), (~x)) &amp;&amp;
    (
        !eq((~b)^2 - 4*(~a)*(~c), 0) ||
        (
            ge((~m), 3) &amp;&amp;
            lt((~m), 4)
        )
    ) &amp;&amp;
    neg((~b)^2 - 4*(~a)*(~c)) &amp;&amp;
    ext_isodd(rt(2*(~q) - (~b)/(~c), 2)) ?
1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2))*∫((~x)^((~m) - 3), (~x)) - 1⨸(2*(~c)*rt(2*(~q) - (~b)⨸(~c), 2)) : nothing</code></pre><h4 id="end"><a class="docs-heading-anchor" href="#end">end</a><a id="end-1"></a><a class="docs-heading-anchor-permalink" href="#end" title="Permalink"></a></h4><p>finally the rule is placed in a tuple (index, rule), and all the tuples are put into a array, ready to be included by load_rules</p><h2 id="Adding-Testsuites"><a class="docs-heading-anchor" href="#Adding-Testsuites">Adding Testsuites</a><a id="Adding-Testsuites-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Testsuites" title="Permalink"></a></h2><p>There is a test suite of 27585 solved integrals taken from the RUBI package, in the folders <code>test/test_files/0 Independent test suites</code> (1796 tests) and <code>test/test_files/1 Algebraic functions</code> (25798 tests). But more test can be translated from the <a href="https://rulebasedintegration.org/testProblems.html">RUBI testsuite</a>. In the branch <code>rules</code> of this repo there are the tests still in Mathematica syntax and a script to translate them to julia.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../../methods/overview/">Integration Methods Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 12 January 2026 13:09">Monday 12 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
